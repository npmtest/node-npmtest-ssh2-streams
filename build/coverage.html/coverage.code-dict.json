{"/home/travis/build/npmtest/node-npmtest-ssh2-streams/test.js":"/* istanbul instrument in package npmtest_ssh2_streams */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/lib.npmtest_ssh2_streams.js":"/* istanbul instrument in package npmtest_ssh2_streams */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ssh2_streams = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ssh2_streams = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ssh2-streams && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ssh2_streams */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ssh2_streams\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ssh2_streams.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ssh2_streams.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ssh2_streams.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ssh2_streams.__dirname + '/lib.npmtest_ssh2_streams.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/node_modules/ssh2-streams/index.js":"module.exports = {\n  SFTPStream: require('./lib/sftp'),\n  SSH2Stream: require('./lib/ssh'),\n  utils: require('./lib/utils'),\n  constants: require('./lib/constants')\n};","/home/travis/build/npmtest/node-npmtest-ssh2-streams/node_modules/ssh2-streams/lib/sftp.js":"// TODO: support EXTENDED request packets\n\nvar TransformStream = require('stream').Transform;\nvar ReadableStream = require('stream').Readable;\nvar WritableStream = require('stream').Writable;\nvar constants = require('fs').constants || process.binding('constants');\nvar util = require('util');\nvar inherits = util.inherits;\nvar isDate = util.isDate;\nvar listenerCount = require('events').EventEmitter.listenerCount;\nvar fs = require('fs');\n\nvar readString = require('./utils').readString;\nvar readInt = require('./utils').readInt;\n\nvar ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000\n};\n\nvar STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\nObject.keys(STATUS_CODE).forEach(function(key) {\n  STATUS_CODE[STATUS_CODE[key]] = key;\n});\nvar STATUS_CODE_STR = {\n  0: 'No error',\n  1: 'End of file',\n  2: 'No such file or directory',\n  3: 'Permission denied',\n  4: 'Failure',\n  5: 'Bad message',\n  6: 'No connection',\n  7: 'Connection lost',\n  8: 'Operation unsupported'\n};\nSFTPStream.STATUS_CODE = STATUS_CODE;\n\nvar REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\nObject.keys(REQUEST).forEach(function(key) {\n  REQUEST[REQUEST[key]] = key;\n});\n\nvar RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\nObject.keys(RESPONSE).forEach(function(key) {\n  RESPONSE[RESPONSE[key]] = key;\n});\n\nvar OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\nSFTPStream.OPEN_MODE = OPEN_MODE;\n\nvar MAX_PKT_LEN = 34000;\nvar MAX_REQID = Math.pow(2, 32) - 1;\nvar CLIENT_VERSION_BUFFER = new Buffer([0, 0, 0, 5 /* length */,\n                                        REQUEST.INIT,\n                                        0, 0, 0, 3 /* version */]);\nvar SERVER_VERSION_BUFFER = new Buffer([0, 0, 0, 5 /* length */,\n                                        RESPONSE.VERSION,\n                                        0, 0, 0, 3 /* version */]);\n/*\n  http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02:\n\n     The maximum size of a packet is in practice determined by the client\n     (the maximum size of read or write requests that it sends, plus a few\n     bytes of packet overhead).  All servers SHOULD support packets of at\n     least 34000 bytes (where the packet size refers to the full length,\n     including the header above).  This should allow for reads and writes\n     of at most 32768 bytes.\n\n  OpenSSH caps this to 256kb instead of the ~34kb as mentioned in the sftpv3\n  spec.\n*/\nvar RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nvar OPENSSH_MAX_DATA_LEN = (256 * 1024) - (2 * 1024)/*account for header data*/;\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SFTPStream(cfg, remoteIdentRaw) {\n  if (typeof cfg === 'string' && !remoteIdentRaw) {\n    remoteIdentRaw = cfg;\n    cfg = undefined;\n  }\n  if (typeof cfg !== 'object' || !cfg)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server ? true : false);\n  this._isOpenSSH = (remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw));\n  this._needContinue = false;\n  this._state = {\n    // common\n    status: 'packet_header',\n    writeReqid: -1,\n    pktLeft: undefined,\n    pktHdrBuf: new Buffer(9), // room for pktLen + pktType + req id\n    pktBuf: undefined,\n    pktType: undefined,\n    version: undefined,\n    extensions: {},\n\n    // client\n    maxDataLen: (this._isOpenSSH ? OPENSSH_MAX_DATA_LEN : 32768),\n    requests: {}\n  };\n\n  var self = this;\n  this.on('end', function() {\n    self.readable = false;\n  }).on('finish', onFinish)\n    .on('prefinish', onFinish);\n  function onFinish() {\n    self.writable = false;\n    self._cleanup(false);\n  }\n\n  if (!this.server)\n    this.push(CLIENT_VERSION_BUFFER);\n}\ninherits(SFTPStream, TransformStream);\n\nSFTPStream.prototype.__read = TransformStream.prototype._read;\nSFTPStream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSFTPStream.prototype.__push = TransformStream.prototype.push;\nSFTPStream.prototype.push = function(chunk, encoding) {\n  if (!this.readable)\n    return false;\n  if (chunk === null)\n    this.readable = false;\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSFTPStream.prototype._cleanup = function(callback) {\n  var state = this._state;\n\n  state.pktBuf = undefined; // give GC something to do\n\n  var requests = state.requests;\n  var keys = Object.keys(requests);\n  var len = keys.length;\n  if (len) {\n    if (this.readable) {\n      var err = new Error('SFTP session ended early');\n      for (var i = 0, cb; i < len; ++i)\n        (cb = requests[keys[i]].cb) && cb(err);\n    }\n    state.requests = {};\n  }\n\n  if (this.readable)\n    this.push(null);\n  else if (!this._readableState.endEmitted && !this._readableState.flowing) {\n    // Ugh!\n    this.resume();\n  }\n  if (callback !== false) {\n    this.debug('DEBUG[SFTP]: Parser: Malformed packet');\n    callback && callback(new Error('Malformed packet'));\n  }\n};\n\nSFTPStream.prototype._transform = function(chunk, encoding, callback) {\n  var state = this._state;\n  var server = this.server;\n  var status = state.status;\n  var pktType = state.pktType;\n  var pktBuf = state.pktBuf;\n  var pktLeft = state.pktLeft;\n  var version = state.version;\n  var pktHdrBuf = state.pktHdrBuf;\n  var requests = state.requests;\n  var debug = this.debug;\n  var chunkLen = chunk.length;\n  var chunkPos = 0;\n  var buffer;\n  var chunkLeft;\n  var id;\n\n  while (true) {\n    if (status === 'discard') {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        status = 'packet_header';\n        buffer = pktBuf = undefined;\n      } else {\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (pktBuf !== undefined) {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunk.copy(pktBuf,\n                   pktBuf.length - pktLeft,\n                   chunkPos,\n                   chunkPos + pktLeft);\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        buffer = pktBuf;\n        pktBuf = undefined;\n        continue;\n      } else {\n        chunk.copy(pktBuf, pktBuf.length - pktLeft, chunkPos);\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (status === 'packet_header') {\n      if (!buffer) {\n        pktLeft = 5;\n        pktBuf = pktHdrBuf;\n      } else {\n        // here we read the right-most 5 bytes from buffer (pktHdrBuf)\n        pktLeft = buffer.readUInt32BE(4, true) - 1; // account for type byte\n        pktType = buffer[8];\n\n        if (server) {\n          if (version === undefined && pktType !== REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected packet before init');\n            status = 'bad_pkt';\n          } else if (version !== undefined && pktType === REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected duplicate init');\n            status = 'bad_pkt';\n          } else if (pktLeft > MAX_PKT_LEN) {\n            debug('DEBUG[SFTP]: Parser: Packet length ('\n                  + pktLeft\n                  + ') exceeds max length ('\n                  + MAX_PKT_LEN\n                  + ')');\n            status = 'bad_pkt';\n          } else if (pktType === REQUEST.EXTENDED)\n            status = 'bad_pkt';\n          else if (REQUEST[pktType] === undefined) {\n            debug('DEBUG[SFTP]: Parser: Unsupported packet type: ' + pktType);\n            status = 'discard';\n          }\n        } else if (version === undefined && pktType !== RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected packet before version');\n          status = 'bad_pkt';\n        } else if (version !== undefined && pktType === RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected duplicate version');\n          status = 'bad_pkt';\n        } else if (RESPONSE[pktType] === undefined)\n          status = 'discard';\n\n        if (status === 'bad_pkt') {\n          // copy original packet info\n          pktHdrBuf.writeUInt32BE(pktLeft, 0, true);\n          pktHdrBuf[4] = pktType;\n\n          pktLeft = 4;\n          pktBuf = pktHdrBuf;\n        } else {\n          pktBuf = new Buffer(pktLeft);\n          status = 'payload';\n        }\n      }\n    } else if (status === 'payload') {\n      if (pktType === RESPONSE.VERSION || pktType === REQUEST.INIT) {\n        /*\n          uint32 version\n          <extension data>\n        */\n        version = state.version = readInt(buffer, 0, this, callback);\n        if (version === false)\n          return;\n        if (version < 3) {\n          this._cleanup();\n          return callback(new Error('Incompatible SFTP version: ' + version));\n        } else if (server)\n          this.push(SERVER_VERSION_BUFFER);\n\n        var buflen = buffer.length;\n        var extname;\n        var extdata;\n        buffer._pos = 4;\n        while (buffer._pos < buflen) {\n          extname = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extname === false)\n            return;\n          extdata = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extdata === false)\n            return;\n          if (state.extensions[extname])\n            state.extensions[extname].push(extdata);\n          else\n            state.extensions[extname] = [ extdata ];\n        }\n\n        this.emit('ready');\n      } else {\n        /*\n          All other packets (client and server) begin with a (client) request\n          id:\n          uint32     id\n        */\n        id = readInt(buffer, 0, this, callback);\n        if (id === false)\n          return;\n\n        var filename;\n        var attrs;\n        var handle;\n        var data;\n\n        if (!server) {\n          var req = requests[id];\n          var cb = req && req.cb;\n          debug('DEBUG[SFTP]: Parser: Response: ' + RESPONSE[pktType]);\n          if (req && cb) {\n            if (pktType === RESPONSE.STATUS) {\n              /*\n                uint32     error/status code\n                string     error message (ISO-10646 UTF-8)\n                string     language tag\n              */\n              var code = readInt(buffer, 4, this, callback);\n              if (code === false)\n                return;\n              if (code === STATUS_CODE.OK) {\n                cb();\n              } else {\n                // We borrow OpenSSH behavior here, specifically we make the\n                // message and language fields optional, despite the\n                // specification requiring them (even if they are empty). This\n                // helps to avoid problems with buggy implementations that do\n                // not fully conform to the SFTP(v3) specification.\n                var msg;\n                var lang = '';\n                if (buffer.length >= 12) {\n                  msg = readString(buffer, 8, 'utf8', this, callback);\n                  if (msg === false)\n                    return;\n                  if ((buffer._pos + 4) < buffer.length) {\n                    lang = readString(buffer,\n                                      buffer._pos,\n                                      'ascii',\n                                      this,\n                                      callback);\n                    if (lang === false)\n                      return;\n                  }\n                }\n                var err = new Error(msg\n                                    || STATUS_CODE_STR[code]\n                                    || 'Unknown status');\n                err.code = code;\n                err.lang = lang;\n                cb(err);\n              }\n            } else if (pktType === RESPONSE.HANDLE) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              cb(undefined, handle);\n            } else if (pktType === RESPONSE.DATA) {\n              /*\n                string     data\n              */\n              if (req.buffer) {\n                // we have already pre-allocated space to store the data\n                var dataLen = readInt(buffer, 4, this, callback);\n                if (dataLen === false)\n                  return;\n                var reqBufLen = req.buffer.length;\n                if (dataLen > reqBufLen) {\n                  // truncate response data to fit expected size\n                  buffer.writeUInt32BE(reqBufLen, 4, true);\n                }\n                data = readString(buffer, 4, req.buffer, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data, dataLen);\n              } else {\n                data = readString(buffer, 4, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data);\n              }\n            } else if (pktType === RESPONSE.NAME) {\n              /*\n                uint32     count\n                repeats count times:\n                        string     filename\n                        string     longname\n                        ATTRS      attrs\n              */\n              var namesLen = readInt(buffer, 4, this, callback);\n              if (namesLen === false)\n                return;\n              var names = [],\n                  longname;\n              buffer._pos = 8;\n              for (var i = 0; i < namesLen; ++i) {\n                // we are going to assume UTF-8 for filenames despite the SFTPv3\n                // spec not specifying an encoding because the specs for newer\n                // versions of the protocol all explicitly specify UTF-8 for\n                // filenames\n                filename = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (filename === false)\n                  return;\n                // `longname` only exists in SFTPv3 and since it typically will\n                // contain the filename, we assume it is also UTF-8\n                longname = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (longname === false)\n                  return;\n                attrs = readAttrs(buffer, buffer._pos, this, callback);\n                if (attrs === false)\n                  return;\n                names.push({\n                  filename: filename,\n                  longname: longname,\n                  attrs: attrs\n                });\n              }\n              cb(undefined, names);\n            } else if (pktType === RESPONSE.ATTRS) {\n              /*\n                ATTRS      attrs\n              */\n              attrs = readAttrs(buffer, 4, this, callback);\n              if (attrs === false)\n                return;\n              cb(undefined, attrs);\n            } else if (pktType === RESPONSE.EXTENDED) {\n              if (req.extended) {\n                switch (req.extended) {\n                  case 'statvfs@openssh.com':\n                  case 'fstatvfs@openssh.com':\n                    /*\n                      uint64    f_bsize   // file system block size\n                      uint64    f_frsize  // fundamental fs block size\n                      uint64    f_blocks  // number of blocks (unit f_frsize)\n                      uint64    f_bfree   // free blocks in file system\n                      uint64    f_bavail  // free blocks for non-root\n                      uint64    f_files   // total file inodes\n                      uint64    f_ffree   // free file inodes\n                      uint64    f_favail  // free file inodes for to non-root\n                      uint64    f_fsid    // file system id\n                      uint64    f_flag    // bit mask of f_flag values\n                      uint64    f_namemax // maximum filename length\n                    */\n                    var stats = {\n                      f_bsize: undefined,\n                      f_frsize: undefined,\n                      f_blocks: undefined,\n                      f_bfree: undefined,\n                      f_bavail: undefined,\n                      f_files: undefined,\n                      f_ffree: undefined,\n                      f_favail: undefined,\n                      f_sid: undefined,\n                      f_flag: undefined,\n                      f_namemax: undefined\n                    };\n                    stats.f_bsize = readUInt64BE(buffer, 4, this, callback);\n                    if (stats.f_bsize === false)\n                      return;\n                    stats.f_frsize = readUInt64BE(buffer, 12, this, callback);\n                    if (stats.f_frsize === false)\n                      return;\n                    stats.f_blocks = readUInt64BE(buffer, 20, this, callback);\n                    if (stats.f_blocks === false)\n                      return;\n                    stats.f_bfree = readUInt64BE(buffer, 28, this, callback);\n                    if (stats.f_bfree === false)\n                      return;\n                    stats.f_bavail = readUInt64BE(buffer, 36, this, callback);\n                    if (stats.f_bavail === false)\n                      return;\n                    stats.f_files = readUInt64BE(buffer, 44, this, callback);\n                    if (stats.f_files === false)\n                      return;\n                    stats.f_ffree = readUInt64BE(buffer, 52, this, callback);\n                    if (stats.f_ffree === false)\n                      return;\n                    stats.f_favail = readUInt64BE(buffer, 60, this, callback);\n                    if (stats.f_favail === false)\n                      return;\n                    stats.f_sid = readUInt64BE(buffer, 68, this, callback);\n                    if (stats.f_sid === false)\n                      return;\n                    stats.f_flag = readUInt64BE(buffer, 76, this, callback);\n                    if (stats.f_flag === false)\n                      return;\n                    stats.f_namemax = readUInt64BE(buffer, 84, this, callback);\n                    if (stats.f_namemax === false)\n                      return;\n                    cb(undefined, stats);\n                  break;\n                }\n              }\n              // XXX: at least provide the raw buffer data to the callback in\n              // case of unexpected extended response?\n              cb();\n            }\n          }\n          if (req)\n            delete requests[id];\n        } else {\n          // server\n          var evName = REQUEST[pktType];\n          var offset;\n          var path;\n\n          debug('DEBUG[SFTP]: Parser: Request: ' + evName);\n          if (listenerCount(this, evName)) {\n            if (pktType === REQUEST.OPEN) {\n              /*\n                string        filename\n                uint32        pflags\n                ATTRS         attrs\n              */\n              filename = readString(buffer, 4, 'utf8', this, callback);\n              if (filename === false)\n                return;\n              var pflags = readInt(buffer, buffer._pos, this, callback);\n              if (pflags === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos + 4, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, filename, pflags, attrs);\n            } else if (pktType === REQUEST.CLOSE\n                       || pktType === REQUEST.FSTAT\n                       || pktType === REQUEST.READDIR) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              this.emit(evName, id, handle);\n            } else if (pktType === REQUEST.READ) {\n              /*\n                string     handle\n                uint64     offset\n                uint32     len\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              var len = readInt(buffer, buffer._pos, this, callback);\n              if (len === false)\n                return;\n              this.emit(evName, id, handle, offset, len);\n            } else if (pktType === REQUEST.WRITE) {\n              /*\n                string     handle\n                uint64     offset\n                string     data\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              data = readString(buffer, buffer._pos, this, callback);\n              if (data === false)\n                return;\n              this.emit(evName, id, handle, offset, data);\n            } else if (pktType === REQUEST.LSTAT\n                       || pktType === REQUEST.STAT\n                       || pktType === REQUEST.OPENDIR\n                       || pktType === REQUEST.REMOVE\n                       || pktType === REQUEST.RMDIR\n                       || pktType === REQUEST.REALPATH\n                       || pktType === REQUEST.READLINK) {\n              /*\n                string     path\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              this.emit(evName, id, path);\n            } else if (pktType === REQUEST.SETSTAT\n                       || pktType === REQUEST.MKDIR) {\n              /*\n                string     path\n                ATTRS      attrs\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, path, attrs);\n            } else if (pktType === REQUEST.FSETSTAT) {\n              /*\n                string     handle\n                ATTRS      attrs\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, handle, attrs);\n            } else if (pktType === REQUEST.RENAME\n                       || pktType === REQUEST.SYMLINK) {\n              /*\n                RENAME:\n                  string     oldpath\n                  string     newpath\n                SYMLINK:\n                  string     linkpath\n                  string     targetpath\n              */\n              var str1;\n              var str2;\n              str1 = readString(buffer, 4, 'utf8', this, callback);\n              if (str1 === false)\n                return;\n              str2 = readString(buffer, buffer._pos, 'utf8', this, callback);\n              if (str2 === false)\n                return;\n              if (pktType === REQUEST.SYMLINK && this._isOpenSSH) {\n                // OpenSSH has linkpath and targetpath positions switched\n                this.emit(evName, id, str2, str1);\n              } else\n                this.emit(evName, id, str1, str2);\n            }\n          } else {\n            // automatically reject request if no handler for request type\n            this.status(id, STATUS_CODE.OP_UNSUPPORTED);\n          }\n        }\n      }\n\n      // prepare for next packet\n      status = 'packet_header';\n      buffer = pktBuf = undefined;\n    } else if (status === 'bad_pkt') {\n      if (server && buffer[4] !== REQUEST.INIT) {\n        var errCode = (buffer[4] === REQUEST.EXTENDED\n                       ? STATUS_CODE.OP_UNSUPPORTED\n                       : STATUS_CODE.FAILURE);\n\n        // no request id for init/version packets, so we have no way to send a\n        // status response, so we just close up shop ...\n        if (buffer[4] === REQUEST.INIT || buffer[4] === RESPONSE.VERSION)\n          return this._cleanup(callback);\n\n        id = readInt(buffer, 5, this, callback);\n        if (id === false)\n          return;\n        this.status(id, errCode);\n      }\n\n      // by this point we have already read the type byte and the id bytes, so\n      // we subtract those from the number of bytes to skip\n      pktLeft = buffer.readUInt32BE(0, true) - 5;\n\n      status = 'discard';\n    }\n\n    if (chunkPos >= chunkLen)\n      break;\n  }\n\n  state.status = status;\n  state.pktType = pktType;\n  state.pktBuf = pktBuf;\n  state.pktLeft = pktLeft;\n  state.version = version;\n\n  callback();\n};\n\n// client\nSFTPStream.prototype.createReadStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new ReadStream(this, path, options);\n};\nSFTPStream.prototype.createWriteStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new WriteStream(this, path, options);\n};\nSFTPStream.prototype.open = function(path, flags_, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n\n  var flags = stringToFlags(flags_);\n  if (flags === null)\n    throw new Error('Unknown flags string: ' + flags_);\n\n  var attrFlags = 0;\n  var attrBytes = 0;\n  if (typeof attrs === 'string' || typeof attrs === 'number') {\n    attrs = { mode: attrs };\n  }\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    attrFlags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32        id\n    string        filename\n    uint32        pflags\n    ATTRS         attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.OPEN;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  buf.writeUInt32BE(flags, p += pathlen, true);\n  buf.writeUInt32BE(attrFlags, p += 4, true);\n  if (attrs && attrFlags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPEN');\n  return this.push(buf);\n};\nSFTPStream.prototype.close = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.CLOSE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing CLOSE');\n  return this.push(buf);\n};\nSFTPStream.prototype.readData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off >= buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var pos = position;\n  var out = new Buffer(4 + 1 + 4 + 4 + handlelen + 8 + 4);\n\n  out.writeUInt32BE(out.length - 4, 0, true);\n  out[4] = REQUEST.READ;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  out.writeUInt32BE(reqid, 5, true);\n\n  out.writeUInt32BE(handlelen, p, true);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  out.writeUInt32BE(len, p += 8, true);\n\n  state.requests[reqid] = {\n    cb: function(err, data, nb) {\n      if (err && err.code !== STATUS_CODE.EOF)\n        return cb(err);\n      cb(undefined, nb || 0, data, position);\n    },\n    buffer: buf.slice(off, off + len)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READ');\n  return this.push(out);\n};\nSFTPStream.prototype.writeData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off > buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var self = this;\n  var state = this._state;\n\n  if (!len) {\n    cb && process.nextTick(function() { cb(undefined, 0); });\n    return;\n  }\n\n  var overflow = (len > state.maxDataLen\n                  ? len - state.maxDataLen\n                  : 0);\n  var origPosition = position;\n\n  if (overflow)\n    len = state.maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    string     data\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var out = new Buffer(4 + 1 + 4 + 4 + handlelen + 8 + 4 + len);\n\n  out.writeUInt32BE(out.length - 4, 0, true);\n  out[4] = REQUEST.WRITE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  out.writeUInt32BE(reqid, 5, true);\n\n  out.writeUInt32BE(handlelen, p, true);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = position & 0xFF;\n    position /= 256;\n  }\n  out.writeUInt32BE(len, p += 8, true);\n  buf.copy(out, p += 4, off, off + len);\n\n  state.requests[reqid] = {\n    cb: function(err) {\n      if (err)\n        cb && cb(err);\n      else if (overflow) {\n        self.writeData(handle,\n                       buf,\n                       off + len,\n                       overflow,\n                       origPosition + len,\n                       cb);\n      } else\n        cb && cb(undefined, off + len);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing WRITE');\n  return this.push(out);\n};\nfunction tryCreateBuffer(size) {\n  try {\n    return new Buffer(size);\n  } catch (ex) {\n    return ex;\n  }\n}\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  var concurrency = 64;\n  var chunkSize = 32768;\n  //var preserve = false;\n  var onstep;\n  var mode;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object') {\n    if (typeof opts.concurrency === 'number'\n        && opts.concurrency > 0\n        && !isNaN(opts.concurrency))\n      concurrency = opts.concurrency;\n    if (typeof opts.chunkSize === 'number'\n        && opts.chunkSize > 0\n        && !isNaN(opts.chunkSize))\n      chunkSize = opts.chunkSize;\n    if (typeof opts.step === 'function')\n      onstep = opts.step;\n    //preserve = (opts.preserve ? true : false);\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number')\n      mode = modeNum(opts.mode);\n  }\n\n  // internal state variables\n  var fsize;\n  var chunk;\n  var psrc = 0;\n  var pdst = 0;\n  var reads = 0;\n  var total = 0;\n  var hadError = false;\n  var srcHandle;\n  var dstHandle;\n  var readbuf;\n  var bufsize = chunkSize * concurrency;\n\n  function onerror(err) {\n    if (hadError)\n      return;\n\n    hadError = true;\n\n    var left = 0;\n    var cbfinal;\n\n    if (srcHandle || dstHandle) {\n      cbfinal = function() {\n        if (--left === 0)\n          cb(err);\n      };\n      if (srcHandle && (src === fs || src.writable))\n        ++left;\n      if (dstHandle && (dst === fs || dst.writable))\n        ++left;\n      if (srcHandle && (src === fs || src.writable))\n        src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.writable))\n        dst.close(dstHandle, cbfinal);\n    } else\n      cb(err);\n  }\n\n  src.open(srcPath, 'r', function(err, sourceHandle) {\n    if (err)\n      return onerror(err);\n\n    srcHandle = sourceHandle;\n\n    src.fstat(srcHandle, function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, function(err_, attrs_) {\n            if (err_)\n              return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n\n      dst.open(dstPath, 'w', function(err, destHandle) {\n        if (err)\n          return onerror(err);\n\n        dstHandle = destHandle;\n\n        if (fsize <= 0)\n          return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error)\n          return onerror(readbuf);\n\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod() for\n              // whatever reason\n              dst.chmod(dstPath, mode, function(err_) {\n                tryAgain();\n              });\n              return;\n            }\n            read();\n          });\n        } else {\n          read();\n        }\n\n        function onread(err, nb, data, dstpos, datapos) {\n          if (err)\n            return onerror(err);\n\n          if (src === fs)\n            dst.writeData(dstHandle, data, datapos || 0, nb, dstpos, writeCb);\n          else\n            dst.write(dstHandle, data, datapos || 0, nb, dstpos, writeCb);\n\n          function writeCb(err) {\n            if (err)\n              return onerror(err);\n\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n\n            if (--reads === 0) {\n              if (total === fsize) {\n                dst.close(dstHandle, function(err) {\n                  dstHandle = undefined;\n                  if (err)\n                    return onerror(err);\n                  src.close(srcHandle, function(err) {\n                    srcHandle = undefined;\n                    if (err)\n                      return onerror(err);\n                    cb();\n                  });\n                });\n              } else\n                read();\n            }\n          }\n        }\n\n        function makeCb(psrc, pdst) {\n          return function(err, nb, data) {\n            onread(err, nb, data, pdst, psrc);\n          };\n        }\n\n        function read() {\n          while (pdst < fsize && reads < concurrency) {\n            chunk = (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            if (src === fs) {\n              src.read(srcHandle,\n                       readbuf,\n                       psrc,\n                       chunk,\n                       pdst,\n                       makeCb(psrc, pdst));\n            } else\n              src.readData(srcHandle, readbuf, psrc, chunk, pdst, onread);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n          psrc = 0;\n        }\n      });\n    });\n  });\n}\nSFTPStream.prototype.fastGet = function(remotePath, localPath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(this, fs, remotePath, localPath, opts, cb);\n};\nSFTPStream.prototype.fastPut = function(localPath, remotePath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(fs, this, localPath, remotePath, opts, cb);\n};\nSFTPStream.prototype.readFile = function(path, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, flag: 'r' };\n  else if (!options)\n    options = { encoding: null, flag: 'r' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  var encoding = options.encoding;\n  if (encoding && !Buffer.isEncoding(encoding))\n    throw new Error('Unknown encoding: ' + encoding);\n\n  // first, stat the file, so we know the size.\n  var size;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n  var pos = 0;\n  var handle;\n\n  // SFTPv3 does not support using -1 for read position, so we have to track\n  // read position manually\n  var bytesRead = 0;\n\n  var flag = options.flag || 'r';\n  this.open(path, flag, 438 /*=0666*/, function(er, handle_) {\n    if (er)\n      return callback && callback(er);\n    handle = handle_;\n\n    self.fstat(handle, function tryStat(er, st) {\n      if (er) {\n        // Try stat() for sftp servers that may not support fstat() for\n        // whatever reason\n        self.stat(path, function(er_, st_) {\n          if (er_) {\n            return self.close(handle, function() {\n              callback && callback(er);\n            });\n          }\n          tryStat(null, st_);\n        });\n        return;\n      }\n\n      size = st.size;\n      if (size === 0) {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffers = [];\n        return read();\n      }\n\n      buffer = new Buffer(size);\n      read();\n    });\n  });\n\n  function read() {\n    if (size === 0) {\n      buffer = new Buffer(8192);\n      self.readData(handle, buffer, 0, 8192, bytesRead, afterRead);\n    } else\n      self.readData(handle, buffer, pos, size - pos, bytesRead, afterRead);\n  }\n\n  function afterRead(er, nbytes) {\n    if (er) {\n      return self.close(handle, function() {\n        return callback && callback(er);\n      });\n    }\n\n    if (nbytes === 0)\n      return close();\n\n    bytesRead += nbytes;\n    pos += nbytes;\n    if (size !== 0) {\n      if (pos === size)\n        close();\n      else\n        read();\n    } else {\n      // unknown size, just read until we don't get bytes.\n      buffers.push(buffer.slice(0, nbytes));\n      read();\n    }\n  }\n\n  function close() {\n    self.close(handle, function(er) {\n      if (size === 0) {\n        // collected the data into the buffers list.\n        buffer = Buffer.concat(buffers, pos);\n      } else if (pos < size)\n        buffer = buffer.slice(0, pos);\n\n      if (encoding)\n        buffer = buffer.toString(encoding);\n      return callback && callback(er, buffer);\n    });\n  }\n};\nfunction writeAll(self, handle, buffer, offset, length, position, callback_) {\n  var callback = (typeof callback_ === 'function' ? callback_ : undefined);\n\n  self.writeData(handle,\n                 buffer,\n                 offset,\n                 length,\n                 position,\n                 function(writeErr, written) {\n    if (writeErr) {\n      return self.close(handle, function() {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length)\n      self.close(handle, callback);\n    else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(self, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\nSFTPStream.prototype.writeFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'w' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (options.encoding && !Buffer.isEncoding(options.encoding))\n    throw new Error('Unknown encoding: ' + options.encoding);\n\n  var flag = options.flag || 'w';\n  this.open(path, flag, options.mode, function(openErr, handle) {\n    if (openErr)\n      callback && callback(openErr);\n    else {\n      var buffer = (Buffer.isBuffer(data)\n                    ? data\n                    : new Buffer('' + data, options.encoding || 'utf8'));\n      var position = (/a/.test(flag) ? null : 0);\n\n      // SFTPv3 does not support the notion of 'current position'\n      // (null position), so we just attempt to append to the end of the file\n      // instead\n      if (position === null) {\n        self.fstat(handle, function tryStat(er, st) {\n          if (er) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            self.stat(path, function(er_, st_) {\n              if (er_) {\n                return self.close(handle, function() {\n                  callback && callback(er);\n                });\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n          writeAll(self, handle, buffer, 0, buffer.length, st.size, callback);\n        });\n        return;\n      }\n      writeAll(self, handle, buffer, 0, buffer.length, position, callback);\n    }\n  });\n};\nSFTPStream.prototype.appendFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'a' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n  this.writeFile(path, data, options, callback);\n};\nSFTPStream.prototype.exists = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  this.stat(path, function(err) {\n    cb && cb(err ? false : true);\n  });\n};\nSFTPStream.prototype.unlink = function(filename, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     filename\n  */\n  var fnamelen = Buffer.byteLength(filename);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + fnamelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.REMOVE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(fnamelen, p, true);\n  buf.write(filename, p += 4, fnamelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REMOVE');\n  return this.push(buf);\n};\nSFTPStream.prototype.rename = function(oldPath, newPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     oldpath\n    string     newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + oldlen + 4 + newlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.RENAME;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(oldlen, p, true);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  buf.writeUInt32BE(newlen, p += oldlen, true);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RENAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.mkdir = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.MKDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  buf.writeUInt32BE(flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing MKDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.rmdir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.RMDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RMDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.readdir = function(where, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n  var doFilter;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof opts !== 'object')\n    opts = {};\n\n  doFilter = (opts && opts.full ? false : true);\n\n  if (!Buffer.isBuffer(where) && typeof where !== 'string')\n    throw new Error('missing directory handle or path');\n\n  if (typeof where === 'string') {\n    var self = this;\n    var entries = [];\n    var e = 0;\n\n    return this.opendir(where, function reread(err, handle) {\n      if (err)\n        return cb(err);\n\n      self.readdir(handle, opts, function(err, list) {\n        var eof = (err && err.code === STATUS_CODE.EOF);\n\n        if (err && !eof) {\n          return self.close(handle, function() {\n            cb(err);\n          });\n        } else if (eof) {\n          return self.close(handle, function(err) {\n            if (err)\n              return cb(err);\n            cb(undefined, entries);\n          });\n        }\n\n        for (var i = 0, len = list.length; i < len; ++i, ++e)\n          entries[e] = list[i];\n\n        reread(undefined, handle);\n      });\n    });\n  }\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = where.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.READDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  where.copy(buf, p += 4);\n\n  state.requests[reqid] = {\n    cb: (doFilter\n         ? function(err, list) {\n             if (err)\n               return cb(err);\n\n             for (var i = list.length - 1; i >= 0; --i) {\n               if (list[i].filename === '.' || list[i].filename === '..')\n                 list.splice(i, 1);\n             }\n\n             cb(undefined, list);\n           }\n         : cb)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.fstat = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.FSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.stat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.STAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.lstat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.LSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing LSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.opendir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.OPENDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPENDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.setstat = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.SETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  buf.writeUInt32BE(flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.fsetstat = function(handle, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object') {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     handle\n    ATTRS      attrs\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + handlelen + 4 + attrBytes);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.FSETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(handlelen, p, true);\n  handle.copy(buf, p += 4);\n  buf.writeUInt32BE(flags, p += handlelen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.futimes = function(handle, atime, mtime, cb) {\n  return this.fsetstat(handle, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.utimes = function(path, atime, mtime, cb) {\n  return this.setstat(path, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.fchown = function(handle, uid, gid, cb) {\n  return this.fsetstat(handle, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.chown = function(path, uid, gid, cb) {\n  return this.setstat(path, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.fchmod = function(handle, mode, cb) {\n  return this.fsetstat(handle, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.chmod = function(path, mode, cb) {\n  return this.setstat(path, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.readlink = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.READLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing link info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.symlink = function(targetPath, linkPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     linkpath\n    string     targetpath\n  */\n  var linklen = Buffer.byteLength(linkPath);\n  var targetlen = Buffer.byteLength(targetPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + linklen + 4 + targetlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.SYMLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  if (this._isOpenSSH) {\n    // OpenSSH has linkpath and targetpath positions switched\n    buf.writeUInt32BE(targetlen, p, true);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n    buf.writeUInt32BE(linklen, p += targetlen, true);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n  } else {\n    buf.writeUInt32BE(linklen, p, true);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n    buf.writeUInt32BE(targetlen, p += linklen, true);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SYMLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.realpath = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.REALPATH;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing path info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REALPATH');\n  return this.push(buf);\n};\n// extended requests\nSFTPStream.prototype.ext_openssh_rename = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['posix-rename@openssh.com']\n           || state.extensions['posix-rename@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"posix-rename@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 24 + 4 + oldlen + 4 + newlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(24, p, true);\n  buf.write('posix-rename@openssh.com', p += 4, 24, 'ascii');\n\n  buf.writeUInt32BE(oldlen, p += 24, true);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  buf.writeUInt32BE(newlen, p += oldlen, true);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing posix-rename@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_statvfs = function(path, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['statvfs@openssh.com']\n           || state.extensions['statvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"statvfs@openssh.com\"\n    string    path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 19 + 4 + pathlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(19, p, true);\n  buf.write('statvfs@openssh.com', p += 4, 19, 'ascii');\n\n  buf.writeUInt32BE(pathlen, p += 19, true);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'statvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing statvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fstatvfs = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fstatvfs@openssh.com']\n           || state.extensions['fstatvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fstatvfs@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 20 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(20, p, true);\n  buf.write('fstatvfs@openssh.com', p += 4, 20, 'ascii');\n\n  buf.writeUInt32BE(handlelen, p += 20, true);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'fstatvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fstatvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_hardlink = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['hardlink@openssh.com']\n           || state.extensions['hardlink@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"hardlink@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 20 + 4 + oldlen + 4 + newlen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(20, p, true);\n  buf.write('hardlink@openssh.com', p += 4, 20, 'ascii');\n\n  buf.writeUInt32BE(oldlen, p += 20, true);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  buf.writeUInt32BE(newlen, p += oldlen, true);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing hardlink@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fsync = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fsync@openssh.com']\n           || state.extensions['fsync@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fsync@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = new Buffer(4 + 1 + 4 + 4 + 17 + 4 + handlelen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  buf.writeUInt32BE(reqid, 5, true);\n  buf.writeUInt32BE(17, p, true);\n  buf.write('fsync@openssh.com', p += 4, 17, 'ascii');\n\n  buf.writeUInt32BE(handlelen, p += 17, true);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fsync@openssh.com');\n  return this.push(buf);\n};\n\n// server\nSFTPStream.prototype.status = function(id, code, message, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!STATUS_CODE[code] || typeof code !== 'number')\n    throw new Error('Bad status code: ' + code);\n\n  message || (message = '');\n  lang || (lang = '');\n\n  var msgLen = Buffer.byteLength(message);\n  var langLen = Buffer.byteLength(lang);\n  var buf = new Buffer(4 + 1 + 4 + 4 + 4 + msgLen + 4 + langLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.STATUS;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(code, 9, true);\n\n  buf.writeUInt32BE(msgLen, 13, true);\n  if (msgLen)\n    buf.write(message, 17, msgLen, 'utf8');\n\n  buf.writeUInt32BE(langLen, 17 + msgLen, true);\n  if (langLen)\n    buf.write(lang, 17 + msgLen + 4, langLen, 'ascii');\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STATUS');\n  return this.push(buf);\n};\nSFTPStream.prototype.handle = function(id, handle) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var handleLen = handle.length;\n\n  if (handleLen > 256)\n    throw new Error('handle too large (> 256 bytes)');\n\n  var buf = new Buffer(4 + 1 + 4 + 4 + handleLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.HANDLE;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(handleLen, 9, true);\n  if (handleLen)\n    handle.copy(buf, 13);\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing HANDLE');\n  return this.push(buf);\n};\nSFTPStream.prototype.data = function(id, data, encoding) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var isBuffer = Buffer.isBuffer(data);\n\n  if (!isBuffer && typeof data !== 'string')\n    throw new Error('data is not a Buffer or string');\n\n  if (!isBuffer)\n    encoding || (encoding = 'utf8');\n\n  var dataLen = (isBuffer ? data.length : Buffer.byteLength(data, encoding));\n  var buf = new Buffer(4 + 1 + 4 + 4 + dataLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.DATA;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(dataLen, 9, true);\n  if (dataLen) {\n    if (isBuffer)\n      data.copy(buf, 13);\n    else\n      buf.write(data, 13, dataLen, encoding);\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing DATA');\n  return this.push(buf);\n};\nSFTPStream.prototype.name = function(id, names) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Array.isArray(names) && typeof names === 'object')\n    names = [ names ];\n  else if (!Array.isArray(names))\n    throw new Error('names is not an object or array');\n\n  var count = names.length;\n  var namesLen = 0;\n  var nameAttrs;\n  var attrs = [];\n  var name;\n  var filename;\n  var longname;\n  var attr;\n  var len;\n  var len2;\n  var buf;\n  var p;\n  var i;\n  var j;\n  var k;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    namesLen += 4 + Buffer.byteLength(filename);\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    namesLen += 4 + Buffer.byteLength(longname);\n\n    if (typeof name.attrs === 'object') {\n      nameAttrs = attrsToBytes(name.attrs);\n      namesLen += 4 + nameAttrs.nbytes;\n      attrs.push(nameAttrs);\n    } else {\n      namesLen += 4;\n      attrs.push(null);\n    }\n  }\n\n  buf = new Buffer(4 + 1 + 4 + 4 + namesLen);\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.NAME;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(count, 9, true);\n\n  p = 13;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    len = Buffer.byteLength(filename);\n    buf.writeUInt32BE(len, p, true);\n    p += 4;\n    if (len) {\n      buf.write(filename, p, len, 'utf8');\n      p += len;\n    }\n\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    len = Buffer.byteLength(longname);\n    buf.writeUInt32BE(len, p, true);\n    p += 4;\n    if (len) {\n      buf.write(longname, p, len, 'utf8');\n      p += len;\n    }\n\n    attr = attrs[i];\n    if (attr) {\n      buf.writeUInt32BE(attr.flags, p, true);\n      p += 4;\n      if (attr.flags && attr.bytes) {\n        var bytes = attr.bytes;\n        for (j = 0, len = bytes.length; j < len; ++j)\n          for (k = 0, len2 = bytes[j].length; k < len2; ++k)\n            buf[p++] = bytes[j][k];\n      }\n    } else {\n      buf.writeUInt32BE(0, p, true);\n      p += 4;\n    }\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing NAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.attrs = function(id, attrs) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (typeof attrs !== 'object')\n    throw new Error('attrs is not an object');\n\n  var info = attrsToBytes(attrs);\n  var buf = new Buffer(4 + 1 + 4 + 4 + info.nbytes);\n  var p = 13;\n\n  buf.writeUInt32BE(buf.length - 4, 0, true);\n  buf[4] = RESPONSE.ATTRS;\n  buf.writeUInt32BE(id, 5, true);\n\n  buf.writeUInt32BE(info.flags, 9, true);\n\n  if (info.flags && info.bytes) {\n    var bytes = info.bytes;\n    for (var j = 0, len = bytes.length; j < len; ++j)\n      for (var k = 0, len2 = bytes[j].length; k < len2; ++k)\n        buf[p++] = bytes[j][k];\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing ATTRS');\n  return this.push(buf);\n};\n\nfunction readAttrs(buf, p, stream, callback) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  var flags = buf.readUInt32BE(p, true);\n  var attrs = new Stats();\n\n  p += 4;\n\n  if (flags & ATTR.SIZE) {\n    var size = readUInt64BE(buf, p, stream, callback);\n    if (size === false)\n      return false;\n    attrs.size = size;\n    p += 8;\n  }\n  if (flags & ATTR.UIDGID) {\n    var uid;\n    var gid;\n    uid = readInt(buf, p, this, callback);\n    if (uid === false)\n      return false;\n    attrs.uid = uid;\n    p += 4;\n    gid = readInt(buf, p, this, callback);\n    if (gid === false)\n      return false;\n    attrs.gid = gid;\n    p += 4;\n  }\n  if (flags & ATTR.PERMISSIONS) {\n    var mode = readInt(buf, p, this, callback);\n    if (mode === false)\n      return false;\n    attrs.mode = mode;\n    // backwards compatibility\n    attrs.permissions = mode;\n    p += 4;\n  }\n  if (flags & ATTR.ACMODTIME) {\n    var atime;\n    var mtime;\n    atime = readInt(buf, p, this, callback);\n    if (atime === false)\n      return false;\n    attrs.atime = atime;\n    p += 4;\n    mtime = readInt(buf, p, this, callback);\n    if (mtime === false)\n      return false;\n    attrs.mtime = mtime;\n    p += 4;\n  }\n  if (flags & ATTR.EXTENDED) {\n    // TODO: read/parse extended data\n    var extcount = readInt(buf, p, this, callback);\n    if (extcount === false)\n      return false;\n    p += 4;\n    for (var i = 0, len; i < extcount; ++i) {\n      len = readInt(buf, p, this, callback);\n      if (len === false)\n        return false;\n      p += 4 + len;\n    }\n  }\n\n  buf._pos = p;\n\n  return attrs;\n}\n\nfunction readUInt64BE(buffer, p, stream, callback) {\n  if ((buffer.length - p) < 8) {\n    stream && stream._cleanup(callback);\n    return false;\n  }\n\n  var val = 0;\n\n  for (var len = p + 8; p < len; ++p) {\n    val *= 256;\n    val += buffer[p];\n  }\n\n  buffer._pos = p;\n\n  return val;\n}\n\nfunction attrsToBytes(attrs) {\n  var flags = 0;\n  var attrBytes = 0;\n  var ret = [];\n  var i = 0;\n\n  if (typeof attrs.size === 'number') {\n    flags |= ATTR.SIZE;\n    attrBytes += 8;\n    var sizeBytes = new Array(8);\n    var val = attrs.size;\n    for (i = 7; i >= 0; --i) {\n      sizeBytes[i] = val & 0xFF;\n      val /= 256;\n    }\n    ret.push(sizeBytes);\n  }\n  if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n    flags |= ATTR.UIDGID;\n    attrBytes += 8;\n    ret.push([(attrs.uid >> 24) & 0xFF, (attrs.uid >> 16) & 0xFF,\n              (attrs.uid >> 8) & 0xFF, attrs.uid & 0xFF]);\n    ret.push([(attrs.gid >> 24) & 0xFF, (attrs.gid >> 16) & 0xFF,\n              (attrs.gid >> 8) & 0xFF, attrs.gid & 0xFF]);\n  }\n  if (typeof attrs.permissions === 'number'\n      || typeof attrs.permissions === 'string'\n      || typeof attrs.mode === 'number'\n      || typeof attrs.mode === 'string') {\n    var mode = modeNum(attrs.mode || attrs.permissions);\n    flags |= ATTR.PERMISSIONS;\n    attrBytes += 4;\n    ret.push([(mode >> 24) & 0xFF,\n              (mode >> 16) & 0xFF,\n              (mode >> 8) & 0xFF,\n              mode & 0xFF]);\n  }\n  if ((typeof attrs.atime === 'number' || isDate(attrs.atime))\n      && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n    var atime = toUnixTimestamp(attrs.atime);\n    var mtime = toUnixTimestamp(attrs.mtime);\n\n    flags |= ATTR.ACMODTIME;\n    attrBytes += 8;\n    ret.push([(atime >> 24) & 0xFF, (atime >> 16) & 0xFF,\n              (atime >> 8) & 0xFF, atime & 0xFF]);\n    ret.push([(mtime >> 24) & 0xFF, (mtime >> 16) & 0xFF,\n              (mtime >> 8) & 0xFF, mtime & 0xFF]);\n  }\n  // TODO: extended attributes\n\n  return { flags: flags, nbytes: attrBytes, bytes: ret };\n}\n\nfunction toUnixTimestamp(time) {\n  if (typeof time === 'number' && !isNaN(time))\n    return time;\n  else if (isDate(time))\n    return parseInt(time.getTime() / 1000, 10);\n  throw new Error('Cannot parse time: ' + time);\n}\n\nfunction modeNum(mode) {\n  if (typeof mode === 'number' && !isNaN(mode))\n    return mode;\n  else if (typeof mode === 'string')\n    return modeNum(parseInt(mode, 8));\n  throw new Error('Cannot parse mode: ' + mode);\n}\n\nvar stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL\n};\nvar stringFlagMapKeys = Object.keys(stringFlagMap);\n\nfunction stringToFlags(str) {\n  var flags = stringFlagMap[str];\n  if (flags !== undefined)\n    return flags;\n  return null;\n}\nSFTPStream.stringToFlags = stringToFlags;\n\nfunction flagsToString(flags) {\n  for (var i = 0; i < stringFlagMapKeys.length; ++i) {\n    var key = stringFlagMapKeys[i];\n    if (stringFlagMap[key] === flags)\n      return key;\n  }\n  return null;\n}\nSFTPStream.flagsToString = flagsToString;\n\nfunction Stats(initial) {\n  this.mode = (initial && initial.mode);\n  this.permissions = this.mode; // backwards compatiblity\n  this.uid = (initial && initial.uid);\n  this.gid = (initial && initial.gid);\n  this.size = (initial && initial.size);\n  this.atime = (initial && initial.atime);\n  this.mtime = (initial && initial.mtime);\n}\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & constants.S_IFMT) === property);\n};\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\nSFTPStream.Stats = Stats;\n\n\n// ReadStream-related\nvar kMinPoolSpace = 128;\nvar pool;\nfunction allocNewPool(poolSize) {\n  pool = new Buffer(poolSize);\n  pool.used = 0;\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(sftp, path, options);\n\n  var self = this;\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // a little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  ReadableStream.call(this, options);\n\n  this.path = path;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 438/*0666*/ : options.mode;\n\n  this.start = options.start === undefined ? undefined : options.start;\n  this.end = options.end === undefined ? undefined : options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.sftp = sftp;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number')\n      throw new TypeError('start must be a Number');\n    if (this.end === undefined)\n      this.end = Infinity;\n    else if (typeof this.end !== 'number')\n      throw new TypeError('end must be a Number');\n\n    if (this.start > this.end)\n      throw new Error('start must be <= end');\n    else if (this.start < 0)\n      throw new Error('start must be >= zero');\n\n    this.pos = this.start;\n  }\n\n  this.on('end', function() {\n    if (self.autoClose) {\n      self.destroy();\n    }\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(ReadStream, ReadableStream);\n\nReadStream.prototype.open = function() {\n  var self = this;\n  this.sftp.open(this.path, this.flags, this.mode, function(er, handle) {\n    if (er) {\n      self.emit('error', er);\n      this.destroyed = this.closed = true;\n      self.emit('close');\n      return;\n    }\n\n    self.handle = handle;\n    self.emit('open', handle);\n    // start the flow of data.\n    self.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._read(n);\n    });\n  }\n\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    pool = null;\n    allocNewPool(this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.end !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  var self = this;\n  this.sftp.readData(this.handle, pool, pool.used, toRead, this.pos, onread);\n\n  // move the pool positions, and internal position for reading.\n  this.pos += toRead;\n  pool.used += toRead;\n\n  function onread(er, bytesRead) {\n    if (er) {\n      if (self.autoClose)\n        self.destroy();\n      self.emit('error', er);\n    } else {\n      var b = null;\n      if (bytesRead > 0)\n        b = thisPool.slice(start, start + bytesRead);\n\n      self.push(b);\n    }\n  }\n};\n\nReadStream.prototype.destroy = function() {\n  if (this.destroyed)\n    return;\n  this.destroyed = true;\n  if (Buffer.isBuffer(this.handle))\n    this.close();\n};\n\n\nReadStream.prototype.close = function(cb) {\n  var self = this;\n  if (cb)\n    this.once('close', cb);\n  if (this.closed || !Buffer.isBuffer(this.handle)) {\n    if (!Buffer.isBuffer(this.handle)) {\n      this.once('open', close);\n      return;\n    }\n    return process.nextTick(this.emit.bind(this, 'close'));\n  }\n  this.closed = true;\n  close();\n\n  function close(handle) {\n    self.sftp.close(handle || self.handle, function(er) {\n      if (er)\n        self.emit('error', er);\n      else\n        self.emit('close');\n    });\n    self.handle = null;\n  }\n};\n\n\nfunction WriteStream(sftp, path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(sftp, path, options);\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  WritableStream.call(this, options);\n\n  this.path = path;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 438/*0666*/ : options.mode;\n\n  this.start = options.start === undefined ? undefined : options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.sftp = sftp;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number')\n      throw new TypeError('start must be a Number');\n    if (this.start < 0)\n      throw new Error('start must be >= zero');\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', function onclose() {\n    if (this.autoClose)\n      this.close();\n  });\n}\ninherits(WriteStream, WritableStream);\n\nWriteStream.prototype.open = function() {\n  var self = this;\n  this.sftp.open(this.path, this.flags, this.mode, function(er, handle) {\n    if (er) {\n      self.emit('error', er);\n      if (this.autoClose) {\n        this.destroyed = this.closed = true;\n        self.emit('close');\n      }\n      return;\n    }\n\n    self.handle = handle;\n\n    self.sftp.fchmod(handle, self.mode, function tryAgain(err) {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        self.sftp.chmod(self.path, self.mode, function(err_) {\n          tryAgain();\n        });\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (self.flags[0] === 'a') {\n        self.sftp.fstat(handle, function tryStat(err, st) {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            self.sftp.stat(self.path, function(err_, st_) {\n              if (err_) {\n                self.destroy();\n                self.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n\n          self.pos = st.size;\n          self.emit('open', handle);\n        });\n        return;\n      }\n      self.emit('open', handle);\n    });\n  });\n};\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!Buffer.isBuffer(data))\n    return this.emit('error', new Error('Invalid data'));\n\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n  }\n\n  var self = this;\n  this.sftp.writeData(this.handle,\n                      data,\n                      0,\n                      data.length,\n                      this.pos,\n                      function(er, bytes) {\n    if (er) {\n      if (self.autoClose)\n        self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n  }\n\n  var sftp = this.sftp;\n  var handle = this.handle;\n  var writesLeft = data.length;\n  var self = this;\n\n  for (var i = 0; i < data.length; ++i) {\n    var chunk = data[i].chunk;\n\n    sftp.writeData(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n\n  function onwrite(er, bytes) {\n    if (er) {\n      self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    if (--writesLeft === 0)\n      cb();\n  }\n};\n\nWriteStream.prototype.destroy = ReadStream.prototype.destroy;\nWriteStream.prototype.close = ReadStream.prototype.close;\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\n\nmodule.exports = SFTPStream;\n\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/node_modules/ssh2-streams/lib/utils.js":"var crypto = require('crypto');\n\nvar Ber = require('asn1').Ber;\nvar BigInteger = require('./jsbn'); // only for converting PPK -> OpenSSL format\n\nvar SSH_TO_OPENSSL = require('./constants').SSH_TO_OPENSSL;\n\nvar RE_STREAM = /^arcfour/i;\nvar RE_KEY_LEN = /(.{64})/g;\n// XXX the value of 2400 from dropbear is only for certain strings, not all\n// strings. for example the list strings used during handshakes\nvar MAX_STRING_LEN = Infinity;//2400; // taken from dropbear\nvar PPK_IV = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\nmodule.exports = {\n  iv_inc: iv_inc,\n  isStreamCipher: isStreamCipher,\n  readInt: readInt,\n  readString: readString,\n  parseKey: require('./keyParser'),\n  genPublicKey: genPublicKey,\n  convertPPKPrivate: convertPPKPrivate,\n  verifyPPKMAC: verifyPPKMAC,\n  decryptKey: decryptKey,\n  DSASigBERToBare: DSASigBERToBare,\n  DSASigBareToBER: DSASigBareToBER,\n  ECDSASigASN1ToSSH: ECDSASigASN1ToSSH,\n  ECDSASigSSHToASN1: ECDSASigSSHToASN1,\n  RSAKeySSHToASN1: RSAKeySSHToASN1,\n  DSAKeySSHToASN1: DSAKeySSHToASN1,\n  ECDSAKeySSHToASN1: ECDSAKeySSHToASN1\n};\n\nfunction iv_inc(iv) {\n  var n = 12;\n  var c = 0;\n  do {\n    --n;\n    c = iv[n];\n    if (c === 255)\n      iv[n] = 0;\n    else {\n      iv[n] = ++c;\n      return;\n    }\n  } while (n > 4);\n}\n\nfunction isStreamCipher(name) {\n  return RE_STREAM.test(name);\n}\n\nfunction readInt(buffer, start, stream, cb) {\n  var bufferLen = buffer.length;\n  if (start < 0 || start >= bufferLen || (bufferLen - start) < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  return buffer.readUInt32BE(start, true);\n}\n\nfunction DSASigBERToBare(signature) {\n  if (signature.length <= 40)\n    return signature;\n  // This is a quick and dirty way to get from BER encoded r and s that\n  // OpenSSL gives us, to just the bare values back to back (40 bytes\n  // total) like OpenSSH (and possibly others) are expecting\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  var rOffset = 0;\n  var sOffset = 0;\n  if (r.length < 20) {\n    var rNew = new Buffer(20);\n    r.copy(rNew, 1);\n    r = rNew;\n    r[0] = 0;\n  }\n  if (s.length < 20) {\n    var sNew = new Buffer(20);\n    s.copy(sNew, 1);\n    s = sNew;\n    s[0] = 0;\n  }\n  if (r.length > 20 && r[0] === 0x00)\n    rOffset = 1;\n  if (s.length > 20 && s[0] === 0x00)\n    sOffset = 1;\n  var newSig = new Buffer((r.length - rOffset) + (s.length - sOffset));\n  r.copy(newSig, 0, rOffset);\n  s.copy(newSig, r.length - rOffset, sOffset);\n  return newSig;\n}\n\nfunction DSASigBareToBER(signature) {\n  if (signature.length > 40)\n    return signature;\n  // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  var r = signature.slice(0, 20);\n  var s = signature.slice(20);\n  if (r[0] & 0x80) {\n    var rNew = new Buffer(21);\n    rNew[0] = 0x00;\n    r.copy(rNew, 1);\n    r = rNew;\n  } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n    r = r.slice(1);\n  }\n  if (s[0] & 0x80) {\n    var sNew = new Buffer(21);\n    sNew[0] = 0x00;\n    s.copy(sNew, 1);\n    s = sNew;\n  } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  asnWriter.writeBuffer(r, Ber.Integer);\n  asnWriter.writeBuffer(s, Ber.Integer);\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction ECDSASigASN1ToSSH(signature) {\n  if (signature[0] === 0x00)\n    return signature;\n  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  if (r === null || s === null)\n    throw new Error('Invalid signature');\n  var newSig = new Buffer(4 + r.length + 4 + s.length);\n  newSig.writeUInt32BE(r.length, 0, true);\n  r.copy(newSig, 4);\n  newSig.writeUInt32BE(s.length, 4 + r.length, true);\n  s.copy(newSig, 4 + 4 + r.length);\n  return newSig;\n}\n\nfunction ECDSASigSSHToASN1(signature, self, callback) {\n  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n  var r = readString(signature, 0, self, callback);\n  if (r === false)\n    return false;\n  var s = readString(signature, signature._pos, self, callback);\n  if (s === false)\n    return false;\n\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(r, Ber.Integer);\n  asnWriter.writeBuffer(s, Ber.Integer);\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction RSAKeySSHToASN1(key, self, callback) {\n  // Convert SSH key parameters to ASN.1 BER values for OpenSSL\n  var e = readString(key, key._pos, self, callback);\n  if (e === false)\n    return false;\n  var n = readString(key, key._pos, self, callback);\n  if (n === false)\n    return false;\n\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n      // algorithm parameters (RSA has none)\n      asnWriter.writeNull();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(n, Ber.Integer);\n        asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction DSAKeySSHToASN1(key, self, callback) {\n  // Convert SSH key parameters to ASN.1 BER values for OpenSSL\n  var p = readString(key, key._pos, self, callback);\n  if (p === false)\n    return false;\n  var q = readString(key, key._pos, self, callback);\n  if (q === false)\n    return false;\n  var g = readString(key, key._pos, self, callback);\n  if (g === false)\n    return false;\n  var y = readString(key, key._pos, self, callback);\n  if (y === false)\n    return false;\n\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n      // algorithm parameters\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(p, Ber.Integer);\n        asnWriter.writeBuffer(q, Ber.Integer);\n        asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction ECDSAKeySSHToASN1(key, self, callback) {\n  // Convert SSH key parameters to ASN.1 BER values for OpenSSL\n  var curve = readString(key, key._pos, self, callback);\n  if (curve === false)\n    return false;\n  var Q = readString(key, key._pos, self, callback);\n  if (Q === false)\n    return false;\n\n  var ecCurveOID;\n  switch (curve.toString('ascii')) {\n    case 'nistp256':\n      // prime256v1/secp256r1\n      ecCurveOID = '1.2.840.10045.3.1.7';\n      break;\n    case 'nistp384':\n      // secp384r1\n      ecCurveOID = '1.3.132.0.34';\n      break;\n    case 'nistp521':\n      // secp521r1\n      ecCurveOID = '1.3.132.0.35';\n      break;\n    default:\n      return false;\n  }\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n      // algorithm parameters (namedCurve)\n      asnWriter.writeOID(ecCurveOID);\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(Q.length);\n      Q.copy(asnWriter._buf, asnWriter._offset, 0, Q.length);\n      asnWriter._offset += Q.length;\n      // end hack\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return asnWriter.buffer;\n}\n\nfunction decryptKey(keyInfo, passphrase) {\n  if (keyInfo._decrypted || !keyInfo.encryption)\n    return;\n\n  var keylen = 0;\n  var key;\n  var iv;\n  var dc;\n\n  keyInfo.encryption = (SSH_TO_OPENSSL[keyInfo.encryption]\n                        || keyInfo.encryption);\n  switch (keyInfo.encryption) {\n    case 'aes-256-cbc':\n    case 'aes-256-ctr':\n      keylen = 32;\n      break;\n    case 'des-ede3-cbc':\n    case 'des-ede3':\n    case 'aes-192-cbc':\n    case 'aes-192-ctr':\n      keylen = 24;\n      break;\n    case 'aes-128-cbc':\n    case 'aes-128-ctr':\n    case 'cast-cbc':\n    case 'bf-cbc':\n      keylen = 16;\n      break;\n    default:\n      throw new Error('Unsupported cipher for encrypted key: '\n                      + keyInfo.encryption);\n  }\n\n  if (keyInfo.ppk) {\n    iv = PPK_IV;\n\n    key = Buffer.concat([\n      crypto.createHash('sha1')\n            .update('\\x00\\x00\\x00\\x00' + passphrase, 'utf8')\n            .digest(),\n      crypto.createHash('sha1')\n            .update('\\x00\\x00\\x00\\x01' + passphrase, 'utf8')\n            .digest()\n    ]);\n    key = key.slice(0, keylen);\n  } else {\n    iv = new Buffer(keyInfo.extra[0], 'hex');\n\n    key = crypto.createHash('md5')\n                .update(passphrase, 'utf8')\n                .update(iv.slice(0, 8))\n                .digest();\n\n    while (keylen > key.length) {\n      key = Buffer.concat([\n        key,\n        (crypto.createHash('md5')\n               .update(key)\n               .update(passphrase, 'utf8')\n               .update(iv)\n               .digest()).slice(0, 8)\n      ]);\n    }\n    if (key.length > keylen)\n      key = key.slice(0, keylen);\n  }\n\n  dc = crypto.createDecipheriv(keyInfo.encryption, key, iv);\n  dc.setAutoPadding(false);\n  keyInfo.private = Buffer.concat([ dc.update(keyInfo.private), dc.final() ]);\n\n  keyInfo._decrypted = true;\n\n  if (keyInfo.privateOrig) {\n    // Update our original base64-encoded version of the private key\n    var orig = keyInfo.privateOrig.toString('utf8');\n    var newOrig = /^(.+(?:\\r\\n|\\n))/.exec(orig)[1];\n    var b64key = keyInfo.private.toString('base64');\n\n    newOrig += b64key.match(/.{1,70}/g).join('\\n');\n    newOrig += /((?:\\r\\n|\\n).+)$/.exec(orig)[1];\n\n    keyInfo.privateOrig = newOrig;\n  } else if (keyInfo.ppk) {\n    var valid = verifyPPKMAC(keyInfo, passphrase, keyInfo.private);\n    if (!valid)\n      throw new Error('PPK MAC mismatch');\n    // Automatically convert private key data to OpenSSL format\n    // (including PEM)\n    convertPPKPrivate(keyInfo);\n  }\n\n  // Fill in full key type\n  // TODO: make DRY, we do this also in keyParser\n  if (keyInfo.type !== 'ec') {\n    keyInfo.fulltype = 'ssh-' + keyInfo.type;\n  } else {\n    // ECDSA\n    var asnReader = new Ber.Reader(keyInfo.private);\n    asnReader.readSequence();\n    asnReader.readInt();\n    asnReader.readString(Ber.OctetString, true);\n    asnReader.readByte(); // Skip \"complex\" context type byte\n    var offset = asnReader.readLength(); // Skip context length\n    if (offset !== null) {\n      asnReader._offset = offset;\n      switch (asnReader.readOID()) {\n        case '1.2.840.10045.3.1.7':\n          // prime256v1/secp256r1\n          keyInfo.fulltype = 'ecdsa-sha2-nistp256';\n          break;\n        case '1.3.132.0.34':\n          // secp384r1\n          keyInfo.fulltype = 'ecdsa-sha2-nistp384';\n          break;\n        case '1.3.132.0.35':\n          // secp521r1\n          keyInfo.fulltype = 'ecdsa-sha2-nistp521';\n          break;\n      }\n    }\n    if (keyInfo.fulltype === undefined)\n      return new Error('Unsupported EC private key type');\n  }\n}\n\nfunction genPublicKey(keyInfo) {\n  var publicKey;\n  var i;\n\n  // RSA\n  var n;\n  var e;\n\n  // DSA\n  var p;\n  var q;\n  var g;\n  var y;\n\n  // ECDSA\n  var d;\n  var Q;\n  var ecCurveOID;\n  var ecCurveName;\n\n  if (keyInfo.private) {\n    // parsing private key in ASN.1 format in order to generate a public key\n    var privKey = keyInfo.private;\n    var asnReader = new Ber.Reader(privKey);\n    var errMsg;\n\n    if (asnReader.readSequence() === null) {\n      errMsg = 'Malformed private key (expected sequence)';\n      if (keyInfo._decrypted)\n        errMsg += '. Bad passphrase?';\n      throw new Error(errMsg);\n    }\n\n    // version (ignored)\n    if (asnReader.readInt() === null) {\n      errMsg = 'Malformed private key (expected version)';\n      if (keyInfo._decrypted)\n        errMsg += '. Bad passphrase?';\n      throw new Error(errMsg);\n    }\n\n    if (keyInfo.type === 'rsa') {\n      // modulus (n) -- integer\n      n = asnReader.readString(Ber.Integer, true);\n      if (n === null) {\n        errMsg = 'Malformed private key (expected RSA n value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // public exponent (e) -- integer\n      e = asnReader.readString(Ber.Integer, true);\n      if (e === null) {\n        errMsg = 'Malformed private key (expected RSA e value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      publicKey = new Buffer(4 + 7 // ssh-rsa\n                             + 4 + n.length\n                             + 4 + e.length);\n\n      publicKey.writeUInt32BE(7, 0, true);\n      publicKey.write('ssh-rsa', 4, 7, 'ascii');\n\n      i = 4 + 7;\n      publicKey.writeUInt32BE(e.length, i, true);\n      e.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(n.length, i += e.length, true);\n      n.copy(publicKey, i += 4);\n    } else if (keyInfo.type === 'dss') { // DSA\n      // prime (p) -- integer\n      p = asnReader.readString(Ber.Integer, true);\n      if (p === null) {\n        errMsg = 'Malformed private key (expected DSA p value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // group order (q) -- integer\n      q = asnReader.readString(Ber.Integer, true);\n      if (q === null) {\n        errMsg = 'Malformed private key (expected DSA q value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // group generator (g) -- integer\n      g = asnReader.readString(Ber.Integer, true);\n      if (g === null) {\n        errMsg = 'Malformed private key (expected DSA g value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      // public key value (y) -- integer\n      y = asnReader.readString(Ber.Integer, true);\n      if (y === null) {\n        errMsg = 'Malformed private key (expected DSA y value)';\n        if (keyInfo._decrypted)\n          errMsg += '. Bad passphrase?';\n        throw new Error(errMsg);\n      }\n\n      publicKey = new Buffer(4 + 7 // ssh-dss\n                             + 4 + p.length\n                             + 4 + q.length\n                             + 4 + g.length\n                             + 4 + y.length);\n\n      publicKey.writeUInt32BE(7, 0, true);\n      publicKey.write('ssh-dss', 4, 7, 'ascii');\n\n      i = 4 + 7;\n      publicKey.writeUInt32BE(p.length, i, true);\n      p.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(q.length, i += p.length, true);\n      q.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(g.length, i += q.length, true);\n      g.copy(publicKey, i += 4);\n\n      publicKey.writeUInt32BE(y.length, i += g.length, true);\n      y.copy(publicKey, i += 4);\n    } else { // ECDSA\n      d = asnReader.readString(Ber.OctetString, true);\n      if (d === null)\n        throw new Error('Malformed private key (expected ECDSA private key)');\n      asnReader.readByte(); // Skip \"complex\" context type byte\n      var offset = asnReader.readLength(); // Skip context length\n      if (offset === null)\n        throw new Error('Malformed private key (expected ECDSA context value)');\n      asnReader._offset = offset;\n      ecCurveOID = asnReader.readOID();\n      if (ecCurveOID === null)\n        throw new Error('Malformed private key (expected ECDSA curve)');\n      var tempECDH;\n      switch (ecCurveOID) {\n        case '1.2.840.10045.3.1.7':\n          // prime256v1/secp256r1\n          keyInfo.curve = ecCurveName = 'nistp256';\n          tempECDH = crypto.createECDH('prime256v1');\n          break;\n        case '1.3.132.0.34':\n          // secp384r1\n          keyInfo.curve = ecCurveName = 'nistp384';\n          tempECDH = crypto.createECDH('secp384r1');\n          break;\n        case '1.3.132.0.35':\n          // secp521r1\n          keyInfo.curve = ecCurveName = 'nistp521';\n          tempECDH = crypto.createECDH('secp521r1');\n          break;\n        default:\n          throw new Error('Malformed private key (unsupported EC curve)');\n      }\n      tempECDH.setPrivateKey(d);\n      Q = tempECDH.getPublicKey();\n\n      publicKey = new Buffer(4 + 19 // ecdsa-sha2-<curve name>\n                             + 4 + 8 // <curve name>\n                             + 4 + Q.length);\n\n      publicKey.writeUInt32BE(19, 0, true);\n      publicKey.write('ecdsa-sha2-' + ecCurveName, 4, 19, 'ascii');\n\n      publicKey.writeUInt32BE(8, 23, true);\n      publicKey.write(ecCurveName, 27, 8, 'ascii');\n\n      publicKey.writeUInt32BE(Q.length, 35, true);\n      Q.copy(publicKey, 39);\n    }\n  } else if (keyInfo.public) {\n    publicKey = keyInfo.public;\n    if (keyInfo.type === 'ec') {\n      // TODO: support adding ecdsa-* prefix\n      ecCurveName = keyInfo.curve;\n    } else if (publicKey[0] !== 0\n      // check for missing ssh-{dsa,rsa} prefix\n               || publicKey[1] !== 0\n               || publicKey[2] !== 0\n               || publicKey[3] !== 7\n               || publicKey[4] !== 115\n               || publicKey[5] !== 115\n               || publicKey[6] !== 104\n               || publicKey[7] !== 45\n               || ((publicKey[8] !== 114\n                    || publicKey[9] !== 115\n                    || publicKey[10] !== 97)\n                   &&\n                   ((publicKey[8] !== 100\n                     || publicKey[9] !== 115\n                     || publicKey[10] !== 115)))) {\n      var newPK = new Buffer(4 + 7 + publicKey.length);\n      publicKey.copy(newPK, 11);\n      newPK.writeUInt32BE(7, 0, true);\n      if (keyInfo.type === 'rsa')\n        newPK.write('ssh-rsa', 4, 7, 'ascii');\n      else\n        newPK.write('ssh-dss', 4, 7, 'ascii');\n      publicKey = newPK;\n    }\n  } else\n    throw new Error('Missing data generated by parseKey()');\n\n  // generate a public key format for use with OpenSSL\n\n  i = 4 + 7;\n\n  var fulltype;\n  var asn1KeyBuf;\n  if (keyInfo.type === 'rsa') {\n    fulltype = 'ssh-rsa';\n    asn1KeyBuf = RSAKeySSHToASN1(publicKey.slice(4 + 7));\n  } else if (keyInfo.type === 'dss') {\n    fulltype = 'ssh-dss';\n    asn1KeyBuf = DSAKeySSHToASN1(publicKey.slice(4 + 7));\n  } else { // ECDSA\n    fulltype = 'ecdsa-sha2-' + ecCurveName;\n    asn1KeyBuf = ECDSAKeySSHToASN1(publicKey.slice(4 + 19));\n  }\n\n  if (!asn1KeyBuf)\n    throw new Error('Invalid SSH-formatted public key');\n\n  var b64key = asn1KeyBuf.toString('base64').replace(RE_KEY_LEN, '$1\\n');\n  var fullkey = '-----BEGIN PUBLIC KEY-----\\n'\n                + b64key\n                + (b64key[b64key.length - 1] === '\\n' ? '' : '\\n')\n                + '-----END PUBLIC KEY-----';\n\n  return {\n    type: keyInfo.type,\n    fulltype: fulltype,\n    curve: ecCurveName,\n    public: publicKey,\n    publicOrig: new Buffer(fullkey)\n  };\n}\n\nfunction verifyPPKMAC(keyInfo, passphrase, privateKey) {\n  if (keyInfo._macresult !== undefined)\n    return keyInfo._macresult;\n  else if (!keyInfo.ppk)\n    throw new Error(\"Key isn't a PPK\");\n  else if (!keyInfo.privateMAC)\n    throw new Error('Missing MAC');\n  else if (!privateKey)\n    throw new Error('Missing raw private key data');\n  else if (keyInfo.encryption && typeof passphrase !== 'string')\n    throw new Error('Missing passphrase for encrypted PPK');\n  else if (keyInfo.encryption && !keyInfo._decrypted)\n    throw new Error('PPK must be decrypted before verifying MAC');\n\n  var mac = keyInfo.privateMAC;\n  var typelen = keyInfo.fulltype.length;\n  // encryption algorithm is converted at this point for use with OpenSSL,\n  // so we need to use the original value so that the MAC is calculated\n  // correctly\n  var enc = (keyInfo.encryption ? 'aes256-cbc' : 'none');\n  var enclen = enc.length;\n  var commlen = Buffer.byteLength(keyInfo.comment);\n  var pub = keyInfo.public;\n  var publen = pub.length;\n  var privlen = privateKey.length;\n  var macdata = new Buffer(4 + typelen\n                           + 4 + enclen\n                           + 4 + commlen\n                           + 4 + publen\n                           + 4 + privlen);\n  var p = 0;\n\n  macdata.writeUInt32BE(typelen, p, true);\n  macdata.write(keyInfo.fulltype, p += 4, typelen, 'ascii');\n  macdata.writeUInt32BE(enclen, p += typelen, true);\n  macdata.write(enc, p += 4, enclen, 'ascii');\n  macdata.writeUInt32BE(commlen, p += enclen, true);\n  macdata.write(keyInfo.comment, p += 4, commlen, 'utf8');\n  macdata.writeUInt32BE(publen, p += commlen, true);\n  pub.copy(macdata, p += 4);\n  macdata.writeUInt32BE(privlen, p += publen, true);\n  privateKey.copy(macdata, p += 4);\n\n  if (typeof passphrase !== 'string')\n    passphrase = '';\n\n  var mackey = crypto.createHash('sha1')\n                     .update('putty-private-key-file-mac-key', 'ascii')\n                     .update(passphrase, 'utf8')\n                     .digest();\n\n  var calcMAC = crypto.createHmac('sha1', mackey)\n                      .update(macdata)\n                      .digest('hex');\n\n  return (keyInfo._macresult = (calcMAC === mac));\n}\n\nfunction convertPPKPrivate(keyInfo) {\n  if (!keyInfo.ppk || !keyInfo.public || !keyInfo.private)\n    throw new Error(\"Key isn't a PPK\");\n  else if (keyInfo._converted)\n    return false;\n\n  var pub = keyInfo.public;\n  var priv = keyInfo.private;\n  var asnWriter = new Ber.Writer();\n  var p;\n  var q;\n\n  if (keyInfo.type === 'rsa') {\n    var e = readString(pub, 4 + 7);\n    var n = readString(pub, pub._pos);\n    var d = readString(priv, 0);\n    p = readString(priv, priv._pos);\n    q = readString(priv, priv._pos);\n    var iqmp = readString(priv, priv._pos);\n    var p1 = new BigInteger(p, 256);\n    var q1 = new BigInteger(q, 256);\n    var dmp1 = new BigInteger(d, 256);\n    var dmq1 = new BigInteger(d, 256);\n\n    dmp1 = new Buffer(dmp1.mod(p1.subtract(BigInteger.ONE)).toByteArray());\n    dmq1 = new Buffer(dmq1.mod(q1.subtract(BigInteger.ONE)).toByteArray());\n\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(n, Ber.Integer);\n      asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.writeBuffer(d, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(dmp1, Ber.Integer);\n      asnWriter.writeBuffer(dmq1, Ber.Integer);\n      asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n  } else {\n    p = readString(pub, 4 + 7);\n    q = readString(pub, pub._pos);\n    var g = readString(pub, pub._pos);\n    var y = readString(pub, pub._pos);\n    var x = readString(priv, 0);\n\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.writeBuffer(y, Ber.Integer);\n      asnWriter.writeBuffer(x, Ber.Integer);\n    asnWriter.endSequence();\n  }\n\n  var b64key = asnWriter.buffer.toString('base64').replace(RE_KEY_LEN, '$1\\n');\n  var fullkey = '-----BEGIN '\n                + (keyInfo.type === 'rsa' ? 'RSA' : 'DSA')\n                + ' PRIVATE KEY-----\\n'\n                + b64key\n                + (b64key[b64key.length - 1] === '\\n' ? '' : '\\n')\n                + '-----END '\n                + (keyInfo.type === 'rsa' ? 'RSA' : 'DSA')\n                + ' PRIVATE KEY-----';\n\n  keyInfo.private = asnWriter.buffer;\n  keyInfo.privateOrig = new Buffer(fullkey);\n  keyInfo._converted = true;\n  return true;\n}\n\nfunction readString(buffer, start, encoding, stream, cb, maxLen) {\n  if (encoding && !Buffer.isBuffer(encoding) && typeof encoding !== 'string') {\n    if (typeof cb === 'number')\n      maxLen = cb;\n    cb = stream;\n    stream = encoding;\n    encoding = undefined;\n  }\n\n  start || (start = 0);\n  var bufferLen = buffer.length;\n  var left = (bufferLen - start);\n  var len;\n  var end;\n  if (start < 0 || start >= bufferLen || left < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  len = buffer.readUInt32BE(start, true);\n  if (len > (maxLen || MAX_STRING_LEN) || left < (4 + len)) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  start += 4;\n  end = start + len;\n  buffer._pos = end;\n\n  if (encoding) {\n    if (Buffer.isBuffer(encoding)) {\n      buffer.copy(encoding, 0, start, end);\n      return encoding;\n    } else\n      return buffer.toString(encoding, start, end);\n  } else\n    return buffer.slice(start, end);\n}\n\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/node_modules/ssh2-streams/lib/jsbn.js":"// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// Set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nBigInteger.prototype.am = am3;\ndbits = 28;\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+this.DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:\"0\";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;       // y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2) // pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Extended JavaScript BN functions, required for RSA private ops.\n\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n// Version 1.2: square() API, isProbablePrime fix\n\n// (public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n// (public) return value as integer\nfunction bnIntValue() {\n  if(this.s < 0) {\n    if(this.t == 1) return this[0]-this.DV;\n    else if(this.t == 0) return -1;\n  }\n  else if(this.t == 1) return this[0];\n  else if(this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n}\n\n// (public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n  if(this.s < 0) return -1;\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n\n// (protected) convert to radix string\nfunction bnpToRadix(b) {\n  if(b == null) b = 10;\n  if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b,cs);\n  var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n  this.divRemTo(d,y,z);\n  while(y.signum() > 0) {\n    r = (a+z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d,y,z);\n  }\n  return z.intValue().toString(b) + r;\n}\n\n// (protected) convert from radix string\nfunction bnpFromRadix(s,b) {\n  this.fromInt(0);\n  if(b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n  for(var i = 0; i < s.length; ++i) {\n    var x = intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b*w+x;\n    if(++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w,0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if(j > 0) {\n    this.dMultiply(Math.pow(b,j));\n    this.dAddOffset(w,0);\n  }\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\n  if(\"number\" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if(a < 2) this.fromInt(1);\n    else {\n      this.fromNumber(a,c);\n      if(!this.testBit(a-1))  // force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\n      while(!this.isProbablePrime(b)) {\n        this.dAddOffset(2,0);\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n      }\n    }\n  }\n  else {\n    // new BigInteger(int,RNG)\n    var x = new Array(), t = a&7;\n    x.length = (a>>3)+1;\n    b.nextBytes(x);\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n    this.fromString(x,256);\n  }\n}\n\n// (public) convert to bigendian byte array\nfunction bnToByteArray() {\n  var i = this.t, r = new Array();\n  r[0] = this.s;\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n      r[k++] = d|(this.s<<(this.DB-p));\n    while(i >= 0) {\n      if(p < 8) {\n        d = (this[i]&((1<<p)-1))<<(8-p);\n        d |= this[--i]>>(p+=this.DB-8);\n      }\n      else {\n        d = (this[i]>>(p-=8))&0xff;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if((d&0x80) != 0) d |= -256;\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n      if(k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\n  var i, f, m = Math.min(a.t,this.t);\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n  if(a.t < this.t) {\n    f = a.s&this.DM;\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n    r.t = this.t;\n  }\n  else {\n    f = this.s&this.DM;\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s,a.s);\n  r.clamp();\n}\n\n// (public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n// (public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n// (public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n// (public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n// (public) ~this\nfunction bnNot() {\n  var r = nbi();\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n\n// (public) this << n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n  return r;\n}\n\n// (public) this >> n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n  return r;\n}\n\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n  if(x == 0) return -1;\n  var r = 0;\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\n  if((x&3) == 0) { x >>= 2; r += 2; }\n  if((x&1) == 0) ++r;\n  return r;\n}\n\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n  for(var i = 0; i < this.t; ++i)\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n  if(this.s < 0) return this.t*this.DB;\n  return -1;\n}\n\n// return number of 1 bits in x\nfunction cbit(x) {\n  var r = 0;\n  while(x != 0) { x &= x-1; ++r; }\n  return r;\n}\n\n// (public) return number of set bits\nfunction bnBitCount() {\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n  return r;\n}\n\n// (public) true iff nth bit is set\nfunction bnTestBit(n) {\n  var j = Math.floor(n/this.DB);\n  if(j >= this.t) return(this.s!=0);\n  return((this[j]&(1<<(n%this.DB)))!=0);\n}\n\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r,op,r);\n  return r;\n}\n\n// (public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n// (public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n// (protected) r = this + a\nfunction bnpAddTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]+a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c += a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c += a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c > 0) r[i++] = c;\n  else if(c < -1) r[i++] = this.DV+c;\n  r.t = i;\n  r.clamp();\n}\n\n// (public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n// (public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n// (public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n// (public) this^2\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n// (public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n// (public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(), r = nbi();\n  this.divRemTo(a,q,r);\n  return new Array(q,r);\n}\n\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\n  ++this.t;\n  this.clamp();\n}\n\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\n  if(n == 0) return;\n  while(this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while(this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if(++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n\n// A \"null\" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n// (public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n// (protected) r = lower n words of \"this * a\", a.t <= n\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\n  var i = Math.min(this.t+a.t,n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while(i > 0) r[--i] = 0;\n  var j;\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n  r.clamp();\n}\n\n// (protected) r = \"this * a\" without lower n words, n > 0\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n  --n;\n  var i = r.t = this.t+a.t-n;\n  r.s = 0; // assumes a,this >= 0\n  while(--i >= 0) r[i] = 0;\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n  r.clamp();\n  r.drShiftTo(1,r);\n}\n\n// Barrett modular reduction\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\n  var i = e.bitLength(), k, r = nbv(1), z;\n  if(i <= 0) return r;\n  else if(i < 18) k = 1;\n  else if(i < 48) k = 3;\n  else if(i < 144) k = 4;\n  else if(i < 768) k = 5;\n  else k = 6;\n  if(i < 8)\n    z = new Classic(m);\n  else if(m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n\n  // precomputation\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n  g[1] = z.convert(this);\n  if(k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1],g2);\n    while(n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2,g[n-2],g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j])-1;\n  while(j >= 0) {\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\n    else {\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n    }\n\n    n = k;\n    while((w&1) == 0) { w >>= 1; --n; }\n    if((i -= n) < 0) { i += this.DB; --j; }\n    if(is1) {  // ret == 1, don't bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else {\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n      z.mulTo(r2,g[w],r);\n    }\n\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n      if(--i < 0) { i = this.DB-1; --j; }\n    }\n  }\n  return z.revert(r);\n}\n\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n  var x = (this.s<0)?this.negate():this.clone();\n  var y = (a.s<0)?a.negate():a.clone();\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n  if(g < 0) return x;\n  if(i < g) g = i;\n  if(g > 0) {\n    x.rShiftTo(g,x);\n    y.rShiftTo(g,y);\n  }\n  while(x.signum() > 0) {\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n    if(x.compareTo(y) >= 0) {\n      x.subTo(y,x);\n      x.rShiftTo(1,x);\n    }\n    else {\n      y.subTo(x,y);\n      y.rShiftTo(1,y);\n    }\n  }\n  if(g > 0) y.lShiftTo(g,y);\n  return y;\n}\n\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n  if(n <= 0) return 0;\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\n  if(this.t > 0)\n    if(d == 0) r = this[0]%n;\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n  return r;\n}\n\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(), v = this.clone();\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n  while(u.signum() != 0) {\n    while(u.isEven()) {\n      u.rShiftTo(1,u);\n      if(ac) {\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n        a.rShiftTo(1,a);\n      }\n      else if(!b.isEven()) b.subTo(m,b);\n      b.rShiftTo(1,b);\n    }\n    while(v.isEven()) {\n      v.rShiftTo(1,v);\n      if(ac) {\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n        c.rShiftTo(1,c);\n      }\n      else if(!d.isEven()) d.subTo(m,d);\n      d.rShiftTo(1,d);\n    }\n    if(u.compareTo(v) >= 0) {\n      u.subTo(v,u);\n      if(ac) a.subTo(c,a);\n      b.subTo(d,b);\n    }\n    else {\n      v.subTo(u,v);\n      if(ac) c.subTo(a,c);\n      d.subTo(b,d);\n    }\n  }\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if(d.compareTo(m) >= 0) return d.subtract(m);\n  if(d.signum() < 0) d.addTo(m,d); else return d;\n  if(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n  var i, x = this.abs();\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n    for(i = 0; i < lowprimes.length; ++i)\n      if(x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if(x.isEven()) return false;\n  i = 1;\n  while(i < lowprimes.length) {\n    var m = lowprimes[i], j = i+1;\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if(k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t+1)>>1;\n  if(t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for(var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n    var y = a.modPow(r,this);\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n      while(j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2,this);\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if(y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\n\n// Expose the Barrett function\nBigInteger.prototype.Barrett = Barrett\n\n// BigInteger interfaces not implemented in jsbn:\n\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n\nmodule.exports = BigInteger;\n\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/node_modules/ssh2-streams/lib/constants.js":"var semver = require('semver');\n\nvar i;\nvar keys;\nvar len;\n\nvar MESSAGE = exports.MESSAGE = {\n  // Transport layer protocol -- generic (1-19)\n  DISCONNECT: 1,\n  IGNORE: 2,\n  UNIMPLEMENTED: 3,\n  DEBUG: 4,\n  SERVICE_REQUEST: 5,\n  SERVICE_ACCEPT: 6,\n\n  // Transport layer protocol -- algorithm negotiation (20-29)\n  KEXINIT: 20,\n  NEWKEYS: 21,\n\n  // Transport layer protocol -- key exchange method-specific (30-49)\n\n  // User auth protocol -- generic (50-59)\n  USERAUTH_REQUEST: 50,\n  USERAUTH_FAILURE: 51,\n  USERAUTH_SUCCESS: 52,\n  USERAUTH_BANNER: 53,\n\n  // User auth protocol -- user auth method-specific (60-79)\n\n  // Connection protocol -- generic (80-89)\n  GLOBAL_REQUEST: 80,\n  REQUEST_SUCCESS: 81,\n  REQUEST_FAILURE: 82,\n\n  // Connection protocol -- channel-related (90-127)\n  CHANNEL_OPEN: 90,\n  CHANNEL_OPEN_CONFIRMATION: 91,\n  CHANNEL_OPEN_FAILURE: 92,\n  CHANNEL_WINDOW_ADJUST: 93,\n  CHANNEL_DATA: 94,\n  CHANNEL_EXTENDED_DATA: 95,\n  CHANNEL_EOF: 96,\n  CHANNEL_CLOSE: 97,\n  CHANNEL_REQUEST: 98,\n  CHANNEL_SUCCESS: 99,\n  CHANNEL_FAILURE: 100\n\n  // Reserved for client protocols (128-191)\n\n  // Local extensions (192-155)\n};\nfor (i = 0, keys = Object.keys(MESSAGE), len = keys.length; i < len; ++i)\n  MESSAGE[MESSAGE[keys[i]]] = keys[i];\n// context-specific message codes:\nMESSAGE.KEXDH_INIT = 30;\nMESSAGE.KEXDH_REPLY = 31;\nMESSAGE.KEXDH_GEX_REQUEST = 34;\nMESSAGE.KEXDH_GEX_GROUP = 31;\nMESSAGE.KEXDH_GEX_INIT = 32;\nMESSAGE.KEXDH_GEX_REPLY = 33;\nMESSAGE.KEXECDH_INIT = 30; // included here for completeness\nMESSAGE.KEXECDH_REPLY = 31; // included here for completeness\nMESSAGE.USERAUTH_PASSWD_CHANGEREQ = 60;\nMESSAGE.USERAUTH_PK_OK = 60;\nMESSAGE.USERAUTH_INFO_REQUEST = 60;\nMESSAGE.USERAUTH_INFO_RESPONSE = 61;\n\nvar DYNAMIC_KEXDH_MESSAGE = exports.DYNAMIC_KEXDH_MESSAGE = {};\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_GROUP] = 'KEXDH_GEX_GROUP';\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_REPLY] = 'KEXDH_GEX_REPLY';\n\nvar KEXDH_MESSAGE = exports.KEXDH_MESSAGE = {};\nKEXDH_MESSAGE[MESSAGE.KEXDH_INIT] = 'KEXDH_INIT';\nKEXDH_MESSAGE[MESSAGE.KEXDH_REPLY] = 'KEXDH_REPLY';\n\nvar DISCONNECT_REASON = exports.DISCONNECT_REASON = {\n  HOST_NOT_ALLOWED_TO_CONNECT: 1,\n  PROTOCOL_ERROR: 2,\n  KEY_EXCHANGE_FAILED: 3,\n  RESERVED: 4,\n  MAC_ERROR: 5,\n  COMPRESSION_ERROR: 6,\n  SERVICE_NOT_AVAILABLE: 7,\n  PROTOCOL_VERSION_NOT_SUPPORTED: 8,\n  HOST_KEY_NOT_VERIFIABLE: 9,\n  CONNECTION_LOST: 10,\n  BY_APPLICATION: 11,\n  TOO_MANY_CONNECTIONS: 12,\n  AUTH_CANCELED_BY_USER: 13,\n  NO_MORE_AUTH_METHODS_AVAILABLE: 14,\n  ILLEGAL_USER_NAME: 15\n};\nfor (i = 0, keys = Object.keys(DISCONNECT_REASON), len = keys.length;\n     i < len;\n     ++i) {\n  DISCONNECT_REASON[DISCONNECT_REASON[keys[i]]] = keys[i];\n}\n\nvar CHANNEL_OPEN_FAILURE = exports.CHANNEL_OPEN_FAILURE = {\n  ADMINISTRATIVELY_PROHIBITED: 1,\n  CONNECT_FAILED: 2,\n  UNKNOWN_CHANNEL_TYPE: 3,\n  RESOURCE_SHORTAGE: 4\n};\nfor (i = 0, keys = Object.keys(CHANNEL_OPEN_FAILURE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_OPEN_FAILURE[CHANNEL_OPEN_FAILURE[keys[i]]] = keys[i];\n}\n\nvar TERMINAL_MODE = exports.TERMINAL_MODE = {\n  TTY_OP_END: 0,        // Indicates end of options.\n  VINTR: 1,             // Interrupt character; 255 if none. Similarly for the\n                        //  other characters.  Not all of these characters are\n                        //  supported on all systems.\n  VQUIT: 2,             // The quit character (sends SIGQUIT signal on POSIX\n                        //  systems).\n  VERASE: 3,            // Erase the character to left of the cursor.\n  VKILL: 4,             // Kill the current input line.\n  VEOF: 5,              // End-of-file character (sends EOF from the terminal).\n  VEOL: 6,              // End-of-line character in addition to carriage return\n                        //  and/or linefeed.\n  VEOL2: 7,             // Additional end-of-line character.\n  VSTART: 8,            // Continues paused output (normally control-Q).\n  VSTOP: 9,             // Pauses output (normally control-S).\n  VSUSP: 10,            // Suspends the current program.\n  VDSUSP: 11,           // Another suspend character.\n  VREPRINT: 12,         // Reprints the current input line.\n  VWERASE: 13,          // Erases a word left of cursor.\n  VLNEXT: 14,           // Enter the next character typed literally, even if it\n                        //  is a special character\n  VFLUSH: 15,           // Character to flush output.\n  VSWTCH: 16,           // Switch to a different shell layer.\n  VSTATUS: 17,          // Prints system status line (load, command, pid, etc).\n  VDISCARD: 18,         // Toggles the flushing of terminal output.\n  IGNPAR: 30,           // The ignore parity flag.  The parameter SHOULD be 0\n                        //  if this flag is FALSE, and 1 if it is TRUE.\n  PARMRK: 31,           // Mark parity and framing errors.\n  INPCK: 32,            // Enable checking of parity errors.\n  ISTRIP: 33,           // Strip 8th bit off characters.\n  INLCR: 34,            // Map NL into CR on input.\n  IGNCR: 35,            // Ignore CR on input.\n  ICRNL: 36,            // Map CR to NL on input.\n  IUCLC: 37,            // Translate uppercase characters to lowercase.\n  IXON: 38,             // Enable output flow control.\n  IXANY: 39,            // Any char will restart after stop.\n  IXOFF: 40,            // Enable input flow control.\n  IMAXBEL: 41,          // Ring bell on input queue full.\n  ISIG: 50,             // Enable signals INTR, QUIT, [D]SUSP.\n  ICANON: 51,           // Canonicalize input lines.\n  XCASE: 52,            // Enable input and output of uppercase characters by\n                        //  preceding their lowercase equivalents with \"\\\".\n  ECHO: 53,             // Enable echoing.\n  ECHOE: 54,            // Visually erase chars.\n  ECHOK: 55,            // Kill character discards current line.\n  ECHONL: 56,           // Echo NL even if ECHO is off.\n  NOFLSH: 57,           // Don't flush after interrupt.\n  TOSTOP: 58,           // Stop background jobs from output.\n  IEXTEN: 59,           // Enable extensions.\n  ECHOCTL: 60,          // Echo control characters as ^(Char).\n  ECHOKE: 61,           // Visual erase for line kill.\n  PENDIN: 62,           // Retype pending input.\n  OPOST: 70,            // Enable output processing.\n  OLCUC: 71,            // Convert lowercase to uppercase.\n  ONLCR: 72,            // Map NL to CR-NL.\n  OCRNL: 73,            // Translate carriage return to newline (output).\n  ONOCR: 74,            // Translate newline to carriage return-newline\n                        // (output).\n  ONLRET: 75,           // Newline performs a carriage return (output).\n  CS7: 90,              // 7 bit mode.\n  CS8: 91,              // 8 bit mode.\n  PARENB: 92,           // Parity enable.\n  PARODD: 93,           // Odd parity, else even.\n  TTY_OP_ISPEED: 128,   // Specifies the input baud rate in bits per second.\n  TTY_OP_OSPEED: 129    // Specifies the output baud rate in bits per second.\n};\nfor (i = 0, keys = Object.keys(TERMINAL_MODE), len = keys.length; i < len; ++i)\n  TERMINAL_MODE[TERMINAL_MODE[keys[i]]] = keys[i];\n\nvar CHANNEL_EXTENDED_DATATYPE = exports.CHANNEL_EXTENDED_DATATYPE = {\n  STDERR: 1\n};\nfor (i = 0, keys = Object.keys(CHANNEL_EXTENDED_DATATYPE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_EXTENDED_DATATYPE[CHANNEL_EXTENDED_DATATYPE[keys[i]]] = keys[i];\n}\n\nexports.SIGNALS = ['ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT',\n                   'QUIT', 'SEGV', 'TERM', 'USR1', 'USR2', 'KILL',\n                   'PIPE'];\n\nvar DEFAULT_KEX = [\n  'diffie-hellman-group14-sha1' // REQUIRED\n];\nvar SUPPORTED_KEX = [\n  'diffie-hellman-group1-sha1'  // REQUIRED\n];\nif (semver.gte(process.version, '0.11.12')) {\n  // https://tools.ietf.org/html/rfc4419#section-4\n  DEFAULT_KEX = [\n    'diffie-hellman-group-exchange-sha256'\n  ].concat(DEFAULT_KEX);\n  SUPPORTED_KEX = [\n    'diffie-hellman-group-exchange-sha1'\n  ].concat(SUPPORTED_KEX);\n}\nif (semver.gte(process.version, '0.11.14')) {\n  // https://tools.ietf.org/html/rfc5656#section-10.1\n  DEFAULT_KEX = [\n    'ecdh-sha2-nistp256',\n    'ecdh-sha2-nistp384',\n    'ecdh-sha2-nistp521'\n  ].concat(DEFAULT_KEX);\n}\nvar KEX_BUF = new Buffer(DEFAULT_KEX.join(','), 'ascii');\nSUPPORTED_KEX = DEFAULT_KEX.concat(SUPPORTED_KEX);\n\nvar DEFAULT_SERVER_HOST_KEY = [\n  'ssh-rsa'\n];\nvar SUPPORTED_SERVER_HOST_KEY = [\n  'ssh-dss'\n];\nif (semver.gte(process.version, '5.2.0')) {\n  // ECDSA keys are only supported in v5.2.0+ because of a crypto change that\n  // made it possible to (efficiently) generate an ECDSA public key from a\n  // private key (commit nodejs/node#da5ac55c83eb2c09cfb3baf7875529e8f1113529)\n  DEFAULT_SERVER_HOST_KEY.push(\n    'ecdsa-sha2-nistp256',\n    'ecdsa-sha2-nistp384',\n    'ecdsa-sha2-nistp521'\n  );\n}\nvar SERVER_HOST_KEY_BUF = new Buffer(DEFAULT_SERVER_HOST_KEY.join(','),\n                                     'ascii');\nSUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat(\n  SUPPORTED_SERVER_HOST_KEY\n);\n\nvar DEFAULT_CIPHER = [];\nvar SUPPORTED_CIPHER = [\n  'aes256-cbc',\n  'aes192-cbc',\n  'aes128-cbc',\n  'blowfish-cbc',\n  '3des-cbc',\n\n  // http://tools.ietf.org/html/rfc4345#section-4:\n  'arcfour256',\n  'arcfour128',\n\n  'cast128-cbc',\n  'arcfour'\n];\nif (semver.gte(process.version, '0.11.12')) {\n  // node v0.11.12 introduced support for setting AAD, which is needed for\n  // AES-GCM in SSH2\n  DEFAULT_CIPHER = [\n    // http://tools.ietf.org/html/rfc5647\n    'aes128-gcm',\n    'aes128-gcm@openssh.com',\n    'aes256-gcm',\n    'aes256-gcm@openssh.com'\n  ].concat(DEFAULT_CIPHER);\n}\nDEFAULT_CIPHER = [\n  // http://tools.ietf.org/html/rfc4344#section-4\n  'aes128-ctr',\n  'aes192-ctr',\n  'aes256-ctr'\n].concat(DEFAULT_CIPHER);\nvar CIPHER_BUF = new Buffer(DEFAULT_CIPHER.join(','), 'ascii');\nSUPPORTED_CIPHER = DEFAULT_CIPHER.concat(SUPPORTED_CIPHER);\n\nvar DEFAULT_HMAC = [\n  'hmac-sha2-256',\n  'hmac-sha2-512',\n  'hmac-sha1',\n];\nvar SUPPORTED_HMAC = [\n  'hmac-md5',\n  'hmac-sha2-256-96', // first 96 bits of HMAC-SHA256\n  'hmac-sha2-512-96', // first 96 bits of HMAC-SHA512\n  'hmac-ripemd160',\n  'hmac-sha1-96',     // first 96 bits of HMAC-SHA1\n  'hmac-md5-96'       // first 96 bits of HMAC-MD5\n];\nvar HMAC_BUF = new Buffer(DEFAULT_HMAC.join(','), 'ascii');\nSUPPORTED_HMAC = DEFAULT_HMAC.concat(SUPPORTED_HMAC);\n\nvar DEFAULT_COMPRESS = [\n  'none',\n  'zlib@openssh.com', // ZLIB (LZ77) compression, except\n                      // compression/decompression does not start until after\n                      // successful user authentication\n  'zlib'              // ZLIB (LZ77) compression\n];\nvar SUPPORTED_COMPRESS = [];\nvar COMPRESS_BUF = new Buffer(DEFAULT_COMPRESS.join(','), 'ascii');\nSUPPORTED_COMPRESS = DEFAULT_COMPRESS.concat(SUPPORTED_COMPRESS);\n\nexports.ALGORITHMS = {\n  KEX: DEFAULT_KEX,\n  KEX_BUF: KEX_BUF,\n  SUPPORTED_KEX: SUPPORTED_KEX,\n\n  SERVER_HOST_KEY: DEFAULT_SERVER_HOST_KEY,\n  SERVER_HOST_KEY_BUF: SERVER_HOST_KEY_BUF,\n  SUPPORTED_SERVER_HOST_KEY: SUPPORTED_SERVER_HOST_KEY,\n\n  CIPHER: DEFAULT_CIPHER,\n  CIPHER_BUF: CIPHER_BUF,\n  SUPPORTED_CIPHER: SUPPORTED_CIPHER,\n\n  HMAC: DEFAULT_HMAC,\n  HMAC_BUF: HMAC_BUF,\n  SUPPORTED_HMAC: SUPPORTED_HMAC,\n\n  COMPRESS: DEFAULT_COMPRESS,\n  COMPRESS_BUF: COMPRESS_BUF,\n  SUPPORTED_COMPRESS: SUPPORTED_COMPRESS\n};\nexports.SSH_TO_OPENSSL = {\n  // ECDH key exchange\n  'ecdh-sha2-nistp256': 'prime256v1', // OpenSSL's name for 'secp256r1'\n  'ecdh-sha2-nistp384': 'secp384r1',\n  'ecdh-sha2-nistp521': 'secp521r1',\n  // Ciphers\n  'aes128-gcm': 'aes-128-gcm',\n  'aes256-gcm': 'aes-256-gcm',\n  'aes128-gcm@openssh.com': 'aes-128-gcm',\n  'aes256-gcm@openssh.com': 'aes-256-gcm',\n  '3des-cbc': 'des-ede3-cbc',\n  'blowfish-cbc': 'bf-cbc',\n  'aes256-cbc': 'aes-256-cbc',\n  'aes192-cbc': 'aes-192-cbc',\n  'aes128-cbc': 'aes-128-cbc',\n  'idea-cbc': 'idea-cbc',\n  'cast128-cbc': 'cast-cbc',\n  'rijndael-cbc@lysator.liu.se': 'aes-256-cbc',\n  'arcfour128': 'rc4',\n  'arcfour256': 'rc4',\n  'arcfour512': 'rc4',\n  'arcfour': 'rc4',\n  'camellia128-cbc': 'camellia-128-cbc',\n  'camellia192-cbc': 'camellia-192-cbc',\n  'camellia256-cbc': 'camellia-256-cbc',\n  'camellia128-cbc@openssh.com': 'camellia-128-cbc',\n  'camellia192-cbc@openssh.com': 'camellia-192-cbc',\n  'camellia256-cbc@openssh.com': 'camellia-256-cbc',\n  '3des-ctr': 'des-ede3',\n  'blowfish-ctr': 'bf-ecb',\n  'aes256-ctr': 'aes-256-ctr',\n  'aes192-ctr': 'aes-192-ctr',\n  'aes128-ctr': 'aes-128-ctr',\n  'cast128-ctr': 'cast5-ecb',\n  'camellia128-ctr': 'camellia-128-ecb',\n  'camellia192-ctr': 'camellia-192-ecb',\n  'camellia256-ctr': 'camellia-256-ecb',\n  'camellia128-ctr@openssh.com': 'camellia-128-ecb',\n  'camellia192-ctr@openssh.com': 'camellia-192-ecb',\n  'camellia256-ctr@openssh.com': 'camellia-256-ecb',\n  // HMAC\n  'hmac-sha1-96': 'sha1',\n  'hmac-sha1': 'sha1',\n  'hmac-sha2-256': 'sha256',\n  'hmac-sha2-256-96': 'sha256',\n  'hmac-sha2-512': 'sha512',\n  'hmac-sha2-512-96': 'sha512',\n  'hmac-md5-96': 'md5',\n  'hmac-md5': 'md5',\n  'hmac-ripemd160': 'ripemd160'\n};\n\nvar BUGS = exports.BUGS = {\n  BAD_DHGEX: 1,\n  OLD_EXIT: 2,\n  DYN_RPORT_BUG: 4\n};\n\nexports.BUGGY_IMPLS = [\n  [ 'Cisco-1.25', BUGS.BAD_DHGEX ],\n  [ /^[0-9.]+$/, BUGS.OLD_EXIT ], // old SSH.com implementations\n  [ /^OpenSSH_5\\.\\d+/, BUGS.DYN_RPORT_BUG ]\n];\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/node_modules/ssh2-streams/lib/keyParser.js":"// TODO:\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n\nvar utils;\nvar Ber = require('asn1').Ber;\nvar semver = require('semver');\n\nvar RE_PPK = /^PuTTY-User-Key-File-2: ssh-(rsa|dss)\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\nvar RE_HEADER_OPENSSH_PRIV = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----$/i;\nvar RE_FOOTER_OPENSSH_PRIV = /^-----END (?:RSA|DSA|EC) PRIVATE KEY-----$/i;\nvar RE_HEADER_OPENSSH_PUB = /^((?:(?:ssh-(rsa|dss))|ecdsa-sha2-nistp(256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z\\/+=]+)(?:$|\\s+([\\S].*)?)$/i;\nvar RE_HEADER_RFC4716_PUB = /^---- BEGIN SSH2 PUBLIC KEY ----$/i;\nvar RE_FOOTER_RFC4716_PUB = /^---- END SSH2 PUBLIC KEY ----$/i;\nvar RE_HEADER_OPENSSH = /^([^:]+):\\s*([\\S].*)?$/i;\nvar RE_HEADER_RFC4716 = /^([^:]+): (.*)?$/i;\n\nmodule.exports = function(data) {\n  if (Buffer.isBuffer(data))\n    data = data.toString('utf8');\n  else if (typeof data !== 'string')\n    return new Error('Key data must be a Buffer or string');\n\n  var ret = {\n    fulltype: undefined,\n    type: undefined,\n    curve: undefined,\n    extra: undefined,\n    comment: undefined,\n    encryption: undefined,\n    private: undefined,\n    privateOrig: undefined,\n    public: undefined,\n    publicOrig: undefined\n  };\n  var m;\n  var i;\n  var len;\n\n  data = data.trim().split(/\\r\\n|\\n/);\n\n  while (!data[0].length)\n    data.shift();\n  while (!data.slice(-1)[0].length)\n    data.pop();\n\n  var orig = data.join('\\n');\n\n  if ((m = RE_HEADER_OPENSSH_PRIV.exec(data[0]))\n      && RE_FOOTER_OPENSSH_PRIV.test(data.slice(-1))) {\n    // OpenSSH private key\n    var keyType = m[1].toLowerCase();\n    if (keyType === 'dsa')\n      keyType = 'dss';\n\n    if (keyType === 'ec' && semver.lt(process.version, '5.2.0')) {\n      return new Error(\n        'EC private keys are not supported in this version of node'\n      );\n    }\n\n    if (!RE_HEADER_OPENSSH.test(data[1])) {\n      // unencrypted, no headers\n      var privData = new Buffer(data.slice(1, -1).join(''), 'base64');\n      if (keyType !== 'ec') {\n        ret.fulltype = 'ssh-' + keyType;\n      } else {\n        // ECDSA\n        var asnReader = new Ber.Reader(privData);\n        asnReader.readSequence();\n        asnReader.readInt();\n        asnReader.readString(Ber.OctetString, true);\n        asnReader.readByte(); // Skip \"complex\" context type byte\n        var offset = asnReader.readLength(); // Skip context length\n        if (offset !== null) {\n          asnReader._offset = offset;\n          switch (asnReader.readOID()) {\n            case '1.2.840.10045.3.1.7':\n              // prime256v1/secp256r1\n              ret.fulltype = 'ecdsa-sha2-nistp256';\n              break;\n            case '1.3.132.0.34':\n              // secp384r1\n              ret.fulltype = 'ecdsa-sha2-nistp384';\n              break;\n            case '1.3.132.0.35':\n              // secp521r1\n              ret.fulltype = 'ecdsa-sha2-nistp521';\n              break;\n          }\n        }\n        if (ret.fulltype === undefined)\n          return new Error('Unsupported EC private key type');\n      }\n      ret.private = privData;\n    } else {\n      // possibly encrypted, headers\n      for (i = 1, len = data.length; i < len; ++i) {\n        m = RE_HEADER_OPENSSH.exec(data[i]);\n        if (m) {\n          m[1] = m[1].toLowerCase();\n          if (m[1] === 'dek-info') {\n            m[2] = m[2].split(',');\n            ret.encryption = m[2][0].toLowerCase();\n            if (m[2].length > 1)\n              ret.extra = m[2].slice(1);\n          }\n        } else if (data[i].length)\n          break;\n      }\n      ret.private = new Buffer(data.slice(i, -1).join(''), 'base64');\n    }\n    ret.type = keyType;\n    ret.privateOrig = new Buffer(orig);\n  } else if (m = RE_HEADER_OPENSSH_PUB.exec(data[0])) {\n    // OpenSSH public key\n    ret.fulltype = m[1];\n    ret.type = (m[2] || 'ec').toLowerCase();\n    ret.public = new Buffer(m[4], 'base64');\n    ret.publicOrig = new Buffer(orig);\n    ret.comment = m[5];\n    if (m[3]) // ECDSA only\n      ret.curve = 'nistp' + m[3];\n  } else if (RE_HEADER_RFC4716_PUB.test(data[0])\n             && RE_FOOTER_RFC4716_PUB.test(data.slice(-1))) {\n    if (data[1].indexOf(': ') === -1) {\n      // no headers\n      ret.public = new Buffer(data.slice(1, -1).join(''), 'base64');\n    } else {\n      // headers\n      for (i = 1, len = data.length; i < len; ++i) {\n        if (data[i].indexOf(': ') === -1) {\n          if (data[i].length)\n            break; // start of key data\n          else\n            continue; // empty line\n        }\n        while (data[i].substr(-1) === '\\\\') {\n          if (i + 1 < len) {\n            data[i] = data[i].slice(0, -1) + data[i + 1];\n            data.splice(i + 1, 1);\n            --len;\n          } else\n            return new Error('RFC4716 public key missing header continuation line');\n        }\n        m = RE_HEADER_RFC4716.exec(data[i]);\n        if (m) {\n          m[1] = m[1].toLowerCase();\n          if (m[1] === 'comment') {\n            ret.comment = m[2] || '';\n            if (ret.comment[0] === '\"' && ret.comment.substr(-1) === '\"')\n              ret.comment = ret.comment.slice(1, -1);\n          }\n        } else\n          return new Error('RFC4716 public key invalid header line');\n      }\n      ret.public = new Buffer(data.slice(i, -1).join(''), 'base64');\n    }\n    len = ret.public.readUInt32BE(0, true);\n    var fulltype = ret.public.toString('ascii', 4, 4 + len);\n    ret.fulltype = fulltype;\n    if (fulltype === 'ssh-dss')\n      ret.type = 'dss';\n    else if (fulltype === 'ssh-rsa')\n      ret.type = 'rsa';\n    else\n      return new Error('Unsupported RFC4716 public key type: ' + fulltype);\n    ret.public = ret.public.slice(11);\n    ret.publicOrig = new Buffer(orig);\n  } else if (m = RE_PPK.exec(orig)) {\n    // m[1] = short type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    ret.ppk = true;\n    ret.type = m[1];\n    ret.fulltype = 'ssh-' + m[1];\n    if (m[2] !== 'none')\n      ret.encryption = m[2];\n    ret.comment = m[3];\n\n    ret.public = new Buffer(m[4].replace(/\\r?\\n/g, ''), 'base64');\n    var privateKey = new Buffer(m[5].replace(/\\r?\\n/g, ''), 'base64');\n\n    ret.privateMAC = m[6].replace(/\\r?\\n/g, '');\n\n    // automatically verify private key MAC if we don't need to wait for\n    // decryption\n    if (!ret.encryption) {\n      var valid = utils.verifyPPKMAC(ret, undefined, privateKey);\n      if (!valid)\n        throw new Error('PPK MAC mismatch');\n    }\n\n    // generate a PEM encoded version of the public key\n    var pubkey = utils.genPublicKey(ret);\n    ret.public = pubkey.public;\n    ret.publicOrig = pubkey.publicOrig;\n\n    ret.private = privateKey;\n\n    // automatically convert private key data to OpenSSL format (including PEM)\n    // if we don't need to wait for decryption\n    if (!ret.encryption)\n      utils.convertPPKPrivate(ret);\n  } else\n    return new Error('Unsupported key format');\n\n  return ret;\n};\n","/home/travis/build/npmtest/node-npmtest-ssh2-streams/node_modules/ssh2-streams/lib/ssh.js":"// TODO: * Automatic re-key every (configurable) n bytes or length of time\n//         - RFC suggests every 1GB of transmitted data or 1 hour, whichever\n//           comes sooner\n//       * Filter control codes from strings\n//         (as per http://tools.ietf.org/html/rfc4251#section-9.2)\n\nvar crypto = require('crypto');\nvar zlib = require('zlib');\nvar TransformStream = require('stream').Transform;\nvar inherits = require('util').inherits;\nvar inspect = require('util').inspect;\nvar BUFFER_MAX_LEN = require('buffer').kMaxLength;\n\nvar StreamSearch = require('streamsearch');\n\nvar consts = require('./constants');\nvar utils = require('./utils');\nvar isStreamCipher = utils.isStreamCipher;\nvar iv_inc = utils.iv_inc;\nvar readString = utils.readString;\nvar readInt = utils.readInt;\nvar DSASigBERToBare = utils.DSASigBERToBare;\nvar DSASigBareToBER = utils.DSASigBareToBER;\nvar ECDSASigSSHToASN1 = utils.ECDSASigSSHToASN1;\nvar ECDSASigASN1ToSSH = utils.ECDSASigASN1ToSSH;\nvar RSAKeySSHToASN1 = utils.RSAKeySSHToASN1;\nvar DSAKeySSHToASN1 = utils.DSAKeySSHToASN1;\nvar ECDSAKeySSHToASN1 = utils.ECDSAKeySSHToASN1;\n\nvar MESSAGE = consts.MESSAGE;\nvar DYNAMIC_KEXDH_MESSAGE = consts.DYNAMIC_KEXDH_MESSAGE;\nvar KEXDH_MESSAGE = consts.KEXDH_MESSAGE;\nvar ALGORITHMS = consts.ALGORITHMS;\nvar DISCONNECT_REASON = consts.DISCONNECT_REASON;\nvar CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;\nvar SSH_TO_OPENSSL = consts.SSH_TO_OPENSSL;\nvar TERMINAL_MODE = consts.TERMINAL_MODE;\nvar SIGNALS = consts.SIGNALS;\nvar BUGS = consts.BUGS;\nvar BUGGY_IMPLS = consts.BUGGY_IMPLS;\nvar BUGGY_IMPLS_LEN = BUGGY_IMPLS.length;\nvar MODULE_VER = require('../package.json').version;\nvar I = 0;\nvar IN_INIT = I++;\nvar IN_GREETING = I++;\nvar IN_HEADER = I++;\nvar IN_PACKETBEFORE = I++;\nvar IN_PACKET = I++;\nvar IN_PACKETDATA = I++;\nvar IN_PACKETDATAVERIFY = I++;\nvar IN_PACKETDATAAFTER = I++;\nvar OUT_INIT = I++;\nvar OUT_READY = I++;\nvar OUT_REKEYING = I++;\nvar MAX_SEQNO = 4294967295;\nvar MAX_PACKET_SIZE = 35000;\nvar MAX_PACKETS_REKEYING = 50;\nvar EXP_TYPE_HEADER = 0;\nvar EXP_TYPE_LF = 1;\nvar EXP_TYPE_BYTES = 2; // Waits until n bytes have been seen\nvar Z_PARTIAL_FLUSH = zlib.Z_PARTIAL_FLUSH;\nvar ZLIB_OPTS = { flush: Z_PARTIAL_FLUSH };\n\nvar RE_KEX_HASH = /-(.+)$/;\nvar RE_GEX = /^gex-/;\nvar RE_NULL = /\\x00/g;\nvar RE_GCM = /^aes\\d+-gcm/i;\n\nvar IDENT_PREFIX_BUFFER = new Buffer('SSH-');\nvar EMPTY_BUFFER = new Buffer(0);\nvar PING_PACKET = new Buffer([\n  MESSAGE.GLOBAL_REQUEST,\n  // \"keepalive@openssh.com\"\n  0, 0, 0, 21,\n    107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,\n    115, 104, 46, 99, 111, 109,\n  // Request a reply\n  1\n]);\nvar NEWKEYS_PACKET = new Buffer([MESSAGE.NEWKEYS]);\nvar USERAUTH_SUCCESS_PACKET = new Buffer([MESSAGE.USERAUTH_SUCCESS]);\nvar REQUEST_SUCCESS_PACKET = new Buffer([MESSAGE.REQUEST_SUCCESS]);\nvar REQUEST_FAILURE_PACKET = new Buffer([MESSAGE.REQUEST_FAILURE]);\nvar NO_TERMINAL_MODES_BUFFER = new Buffer([TERMINAL_MODE.TTY_OP_END]);\nvar KEXDH_GEX_REQ_PACKET = new Buffer([\n  MESSAGE.KEXDH_GEX_REQUEST,\n  // Minimal size in bits of an acceptable group\n  0, 0, 4, 0, // 1024, modp2\n  // Preferred size in bits of the group the server will send\n  0, 0, 10, 0, // 4096, modp16\n  // Maximal size in bits of an acceptable group\n  0, 0, 20, 0 // 8192, modp18\n]);\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SSH2Stream(cfg) {\n  if (typeof cfg !== 'object' || cfg === null)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this._needContinue = false;\n  this.bytesSent = this.bytesReceived = 0;\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server === true);\n  this.maxPacketSize = (typeof cfg.maxPacketSize === 'number'\n                        ? cfg.maxPacketSize\n                        : MAX_PACKET_SIZE);\n  // Bitmap that indicates any bugs the remote side has. This is determined\n  // by the reported software version.\n  this.remoteBugs = 0;\n\n  if (this.server) {\n    // TODO: Remove when we support group exchange for server implementation\n    this.remoteBugs = BUGS.BAD_DHGEX;\n  }\n\n  var self = this;\n\n  var hostKeys = cfg.hostKeys;\n  if (this.server && (typeof hostKeys !== 'object' || hostKeys === null))\n    throw new Error('hostKeys must be an object keyed on host key type');\n\n  this.config = {\n    // Server\n    hostKeys: hostKeys, // All keys supported by server\n\n    // Client/Server\n    ident: 'SSH-2.0-'\n           + (cfg.ident\n              || ('ssh2js' + MODULE_VER + (this.server ? 'srv' : ''))),\n    algorithms: {\n      kex: ALGORITHMS.KEX,\n      kexBuf: ALGORITHMS.KEX_BUF,\n      serverHostKey: ALGORITHMS.SERVER_HOST_KEY,\n      serverHostKeyBuf: ALGORITHMS.SERVER_HOST_KEY_BUF,\n      cipher: ALGORITHMS.CIPHER,\n      cipherBuf: ALGORITHMS.CIPHER_BUF,\n      hmac: ALGORITHMS.HMAC,\n      hmacBuf: ALGORITHMS.HMAC_BUF,\n      compress: ALGORITHMS.COMPRESS,\n      compressBuf: ALGORITHMS.COMPRESS_BUF\n    }\n  };\n  // RFC 4253 states the identification string must not contain NULL\n  this.config.ident.replace(RE_NULL, '');\n\n  if (this.config.ident.length + 2 /* Account for \"\\r\\n\" */ > 255)\n    throw new Error('ident too long');\n\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algos = cfg.algorithms;\n    if (Array.isArray(algos.kex) && algos.kex.length > 0) {\n      this.config.algorithms.kex = algos.kex;\n      if (!Buffer.isBuffer(algos.kexBuf))\n        algos.kexBuf = new Buffer(algos.kex.join(','), 'ascii');\n      this.config.algorithms.kexBuf = algos.kexBuf;\n    }\n    if (Array.isArray(algos.serverHostKey) && algos.serverHostKey.length > 0) {\n      this.config.algorithms.serverHostKey = algos.serverHostKey;\n      if (!Buffer.isBuffer(algos.serverHostKeyBuf)) {\n        algos.serverHostKeyBuf = new Buffer(algos.serverHostKey.join(','),\n                                            'ascii');\n      }\n      this.config.algorithms.serverHostKeyBuf = algos.serverHostKeyBuf;\n    }\n    if (Array.isArray(algos.cipher) && algos.cipher.length > 0) {\n      this.config.algorithms.cipher = algos.cipher;\n      if (!Buffer.isBuffer(algos.cipherBuf))\n        algos.cipherBuf = new Buffer(algos.cipher.join(','), 'ascii');\n      this.config.algorithms.cipherBuf = algos.cipherBuf;\n    }\n    if (Array.isArray(algos.hmac) && algos.hmac.length > 0) {\n      this.config.algorithms.hmac = algos.hmac;\n      if (!Buffer.isBuffer(algos.hmacBuf))\n        algos.hmacBuf = new Buffer(algos.hmac.join(','), 'ascii');\n      this.config.algorithms.hmacBuf = algos.hmacBuf;\n    }\n    if (Array.isArray(algos.compress) && algos.compress.length > 0) {\n      this.config.algorithms.compress = algos.compress;\n      if (!Buffer.isBuffer(algos.compressBuf))\n        algos.compressBuf = new Buffer(algos.compress.join(','), 'ascii');\n      this.config.algorithms.compressBuf = algos.compressBuf;\n    }\n  }\n\n  this.reset(true);\n\n  // Common events\n  this.on('end', function() {\n    // Let GC collect any Buffers we were previously storing\n    self._state = undefined;\n    self.reset();\n    self._state.incoming.hmac.bufCompute = undefined;\n    self._state.outgoing.bufSeqno = undefined;\n  });\n  this.on('DISCONNECT', function(reason, code, desc, lang) {\n    onDISCONNECT(self, reason, code, desc, lang);\n  });\n  this.on('KEXINIT', function(init, firstFollows) {\n    onKEXINIT(self, init, firstFollows);\n  });\n  this.on('NEWKEYS', function() { onNEWKEYS(self); });\n\n  if (this.server) {\n    // Server-specific events\n    this.on('KEXDH_INIT', function(e) { onKEXDH_INIT(self, e); });\n  } else {\n    // Client-specific events\n    this.on('KEXDH_REPLY', function(info) { onKEXDH_REPLY(self, info); })\n        .on('KEXDH_GEX_GROUP',\n            function(prime, gen) { onKEXDH_GEX_GROUP(self, prime, gen); });\n  }\n\n  if (this.server) {\n    // Greeting displayed before the ssh identification string is sent, this is\n    // usually ignored by most clients\n    if (typeof cfg.greeting === 'string' && cfg.greeting.length) {\n      if (cfg.greeting.slice(-2) === '\\r\\n')\n        this.push(cfg.greeting);\n      else\n        this.push(cfg.greeting + '\\r\\n');\n    }\n    // Banner shown after the handshake completes, but before user\n    // authentication begins\n    if (typeof cfg.banner === 'string' && cfg.banner.length) {\n      if (cfg.banner.slice(-2) === '\\r\\n')\n        this.banner = cfg.banner;\n      else\n        this.banner = cfg.banner + '\\r\\n';\n    }\n  }\n  this.debug('DEBUG: Local ident: ' + inspect(this.config.ident));\n  this.push(this.config.ident + '\\r\\n');\n\n  this._state.incoming.expectedPacket = 'KEXINIT';\n}\ninherits(SSH2Stream, TransformStream);\n\nSSH2Stream.prototype.__read = TransformStream.prototype._read;\nSSH2Stream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSSH2Stream.prototype.__push = TransformStream.prototype.push;\nSSH2Stream.prototype.push = function(chunk, encoding) {\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSSH2Stream.prototype._cleanup = function(callback) {\n  this.reset();\n  this.debug('DEBUG: Parser: Malformed packet');\n  callback && callback(new Error('Malformed packet'));\n};\n\nSSH2Stream.prototype._transform = function(chunk, encoding, callback, decomp) {\n  var skipDecrypt = false;\n  var doDecryptGCM = false;\n  var state = this._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var expect = instate.expect;\n  var decrypt = instate.decrypt;\n  var decompress = instate.decompress;\n  var chlen = chunk.length;\n  var chleft = 0;\n  var debug = this.debug;\n  var self = this;\n  var i = 0;\n  var p = i;\n  var buffer;\n  var buf;\n  var r;\n\n  this.bytesReceived += chlen;\n\n  while (true) {\n    if (expect.type !== undefined) {\n      if (i >= chlen)\n        break;\n      if (expect.type === EXP_TYPE_BYTES) {\n        chleft = (chlen - i);\n        var pktLeft = (expect.buf.length - expect.ptr);\n        if (pktLeft <= chleft) {\n          chunk.copy(expect.buf, expect.ptr, i, i + pktLeft);\n          i += pktLeft;\n          buffer = expect.buf;\n          expect.buf = undefined;\n          expect.ptr = 0;\n          expect.type = undefined;\n        } else {\n          chunk.copy(expect.buf, expect.ptr, i);\n          expect.ptr += chleft;\n          i += chleft;\n        }\n        continue;\n      } else if (expect.type === EXP_TYPE_HEADER) {\n        i += instate.search.push(chunk);\n        if (expect.type !== undefined)\n          continue;\n      } else if (expect.type === EXP_TYPE_LF) {\n        if (++expect.ptr + 4 /* Account for \"SSH-\" */ > 255) {\n          this.reset();\n          debug('DEBUG: Parser: Identification string exceeded 255 characters');\n          return callback(new Error('Max identification string size exceeded'));\n        }\n        if (chunk[i] === 0x0A) {\n          expect.type = undefined;\n          if (p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          buffer = expect.buf;\n          expect.buf = undefined;\n          ++i;\n        } else {\n          if (++i === chlen && p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          continue;\n        }\n      }\n    }\n\n    if (instate.status === IN_INIT) {\n      if (this.server) {\n        // Retrieve what should be the start of the protocol version exchange\n        if (!buffer) {\n          debug('DEBUG: Parser: IN_INIT (waiting for identification begin)');\n          expectData(this, EXP_TYPE_BYTES, 4);\n        } else {\n          if (buffer[0] === 0x53       // S\n              && buffer[1] === 0x53    // S\n              && buffer[2] === 0x48    // H\n              && buffer[3] === 0x2D) { // -\n            instate.status = IN_GREETING;\n            debug('DEBUG: Parser: IN_INIT (waiting for rest of identification)');\n          } else {\n            this.reset();\n            debug('DEBUG: Parser: Bad identification start');\n            return callback(new Error('Bad identification start'));\n          }\n        }\n      } else {\n        debug('DEBUG: Parser: IN_INIT');\n        // Retrieve any bytes that may come before the protocol version exchange\n        var ss = instate.search = new StreamSearch(IDENT_PREFIX_BUFFER);\n        ss.on('info', function onInfo(matched, data, start, end) {\n          if (data) {\n            if (instate.greeting === undefined)\n              instate.greeting = data.toString('binary', start, end);\n            else\n              instate.greeting += data.toString('binary', start, end);\n          }\n          if (matched) {\n            expect.type = undefined;\n            instate.search.removeListener('info', onInfo);\n          }\n        });\n        ss.maxMatches = 1;\n        expectData(this, EXP_TYPE_HEADER);\n        instate.status = IN_GREETING;\n      }\n    } else if (instate.status === IN_GREETING) {\n      debug('DEBUG: Parser: IN_GREETING');\n      instate.search = undefined;\n      // Retrieve the identification bytes after the \"SSH-\" header\n      p = i;\n      expectData(this, EXP_TYPE_LF);\n      instate.status = IN_HEADER;\n    } else if (instate.status === IN_HEADER) {\n      debug('DEBUG: Parser: IN_HEADER');\n      buffer = buffer.trim();\n      var idxDash = buffer.indexOf('-');\n      var idxSpace = buffer.indexOf(' ');\n      var header = {\n        // RFC says greeting SHOULD be utf8\n        greeting: instate.greeting,\n        identRaw: 'SSH-' + buffer,\n        versions: {\n          protocol: buffer.substr(0, idxDash),\n          software: (idxSpace === -1\n                     ? buffer.substring(idxDash + 1)\n                     : buffer.substring(idxDash + 1, idxSpace))\n        },\n        comments: (idxSpace > -1 ? buffer.substring(idxSpace + 1) : undefined)\n      };\n      instate.greeting = undefined;\n\n      if (header.versions.protocol !== '1.99'\n          && header.versions.protocol !== '2.0') {\n        this.reset();\n        debug('DEBUG: Parser: protocol version not supported: '\n              + header.versions.protocol);\n        return callback(new Error('Protocol version not supported'));\n      } else\n        this.emit('header', header);\n\n      if (instate.status === IN_INIT) {\n        // We reset from an event handler, possibly due to an unsupported SSH\n        // protocol version?\n        return;\n      }\n\n      var identRaw = header.identRaw;\n      var software = header.versions.software;\n      this.debug('DEBUG: Remote ident: ' + inspect(identRaw));\n      for (var j = 0, rule; j < BUGGY_IMPLS_LEN; ++j) {\n        rule = BUGGY_IMPLS[j];\n        if (typeof rule[0] === 'string') {\n          if (software === rule[0])\n            this.remoteBugs |= rule[1];\n        } else if (rule[0].test(software))\n          this.remoteBugs |= rule[1];\n      }\n      instate.identRaw = identRaw;\n      // Adjust bytesReceived first otherwise it will have an incorrectly larger\n      // total when we call back into this function after completing KEXINIT\n      this.bytesReceived -= (chlen - i);\n      KEXINIT(this, function() {\n        if (i === chlen)\n          callback();\n        else\n          self._transform(chunk.slice(i), encoding, callback);\n      });\n      instate.status = IN_PACKETBEFORE;\n      return;\n    } else if (instate.status === IN_PACKETBEFORE) {\n      debug('DEBUG: Parser: IN_PACKETBEFORE (expecting ' + decrypt.size + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(this, EXP_TYPE_BYTES, decrypt.size, decrypt.buf);\n      instate.status = IN_PACKET;\n    } else if (instate.status === IN_PACKET) {\n      debug('DEBUG: Parser: IN_PACKET');\n      doDecryptGCM = (decrypt.instance && decrypt.isGCM);\n      if (decrypt.instance && !decrypt.isGCM)\n        buffer = decryptData(this, buffer);\n\n      r = readInt(buffer, 0, this, callback);\n      if (r === false)\n        return;\n      var macSize = (instate.hmac.size || 0);\n      var fullPacketLen = r + 4 + macSize;\n      var maxPayloadLen = this.maxPacketSize;\n      if (decompress.instance) {\n        // Account for compressed payloads\n        // This formula is taken from dropbear which derives it from zlib's\n        // documentation. Explanation from dropbear:\n        /* For exact details see http://www.zlib.net/zlib_tech.html\n         * 5 bytes per 16kB block, plus 6 bytes for the stream.\n         * We might allocate 5 unnecessary bytes here if it's an\n         * exact multiple. */\n        maxPayloadLen += (((this.maxPacketSize / 16384) + 1) * 5 + 6);\n      }\n      if (r > maxPayloadLen\n          // TODO: Change 16 to \"MAX(16, decrypt.size)\" when/if SSH2 adopts\n          // 512-bit ciphers\n          || fullPacketLen < (16 + macSize)\n          || ((r + (doDecryptGCM ? 0 : 4)) % decrypt.size) !== 0) {\n        this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n        debug('DEBUG: Parser: Bad packet length (' + fullPacketLen + ')');\n        return callback(new Error('Bad packet length'));\n      }\n\n      instate.pktLen = r;\n      var remainLen = instate.pktLen + 4 - decrypt.size;\n      if (doDecryptGCM) {\n        decrypt.instance.setAAD(buffer.slice(0, 4));\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',remainLen:'\n              + remainLen);\n      } else {\n        instate.padLen = buffer[4];\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',padLen:'\n              + instate.padLen\n              + ',remainLen:'\n              + remainLen);\n      }\n      if (remainLen > 0) {\n        if (doDecryptGCM)\n          instate.pktExtra = buffer.slice(4);\n        else\n          instate.pktExtra = buffer.slice(5);\n        // Grab the rest of the packet\n        expectData(this, EXP_TYPE_BYTES, remainLen);\n        instate.status = IN_PACKETDATA;\n      } else if (remainLen < 0)\n        instate.status = IN_PACKETBEFORE;\n      else {\n        // Entire message fit into one block\n        skipDecrypt = true;\n        instate.status = IN_PACKETDATA;\n        continue;\n      }\n    } else if (instate.status === IN_PACKETDATA) {\n      debug('DEBUG: Parser: IN_PACKETDATA');\n      doDecryptGCM = (decrypt.instance && decrypt.isGCM);\n      if (decrypt.instance && !skipDecrypt && !doDecryptGCM)\n        buffer = decryptData(this, buffer);\n      else if (skipDecrypt)\n        skipDecrypt = false;\n      var padStart = instate.pktLen - instate.padLen - 1;\n      // TODO: Allocate a Buffer once that is slightly larger than maxPacketSize\n      // (to accommodate for packet length field and MAC) and re-use that\n      // instead\n      if (instate.pktExtra) {\n        buf = new Buffer(instate.pktExtra.length + buffer.length);\n        instate.pktExtra.copy(buf);\n        buffer.copy(buf, instate.pktExtra.length);\n        instate.payload = buf.slice(0, padStart);\n      } else {\n        // Entire message fit into one block\n        if (doDecryptGCM)\n          buf = buffer.slice(4);\n        else\n          buf = buffer.slice(5);\n        instate.payload = buffer.slice(5, 5 + padStart);\n      }\n      if (instate.hmac.size !== undefined) {\n        // Wait for hmac hash\n        debug('DEBUG: Parser: HMAC size:' + instate.hmac.size);\n        expectData(this, EXP_TYPE_BYTES, instate.hmac.size, instate.hmac.buf);\n        instate.status = IN_PACKETDATAVERIFY;\n        instate.packet = buf;\n      } else\n        instate.status = IN_PACKETDATAAFTER;\n      instate.pktExtra = undefined;\n      buf = undefined;\n    } else if (instate.status === IN_PACKETDATAVERIFY) {\n      debug('DEBUG: Parser: IN_PACKETDATAVERIFY');\n      // Verify packet data integrity\n      if (hmacVerify(this, buffer)) {\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Valid HMAC)');\n        instate.status = IN_PACKETDATAAFTER;\n        instate.packet = undefined;\n      } else {\n        this.reset();\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Invalid HMAC)');\n        return callback(new Error('Invalid HMAC'));\n      }\n    } else if (instate.status === IN_PACKETDATAAFTER) {\n      if (decompress.instance) {\n        if (!decomp) {\n          debug('DEBUG: Parser: Decompressing');\n          decompress.instance.write(instate.payload);\n          var decompBuf = [];\n          var decompBufLen = 0;\n          decompress.instance.on('readable', function() {\n            var buf;\n            while (buf = this.read()) {\n              decompBuf.push(buf);\n              decompBufLen += buf.length;\n            }\n          }).flush(Z_PARTIAL_FLUSH, function() {\n            decompress.instance.removeAllListeners('readable');\n            if (decompBuf.length === 1)\n              instate.payload = decompBuf[0];\n            else\n              instate.payload = Buffer.concat(decompBuf, decompBufLen);\n            decompBuf = null;\n            var nextSlice;\n            if (i === chlen)\n              nextSlice = EMPTY_BUFFER; // Avoid slicing a zero-length buffer\n            else\n              nextSlice = chunk.slice(i);\n            self._transform(nextSlice, encoding, callback, true);\n          });\n          return;\n        } else {\n          // Make sure we reset this after this first time in the loop,\n          // otherwise we could end up trying to interpret as-is another\n          // compressed packet that is within the same chunk\n          decomp = false;\n        }\n      }\n\n      this.emit('packet');\n\n      var ptype = instate.payload[0];\n\n      if (debug !== DEBUG_NOOP) {\n        var msgPacket = 'DEBUG: Parser: IN_PACKETDATAAFTER, packet: ';\n        var kexdh = state.kexdh;\n        var authMethod = state.authsQueue[0];\n        var msgPktType = null;\n\n        if (outstate.status === OUT_REKEYING\n            && !(ptype <= 4 || (ptype >= 20 && ptype <= 49)))\n          msgPacket += '(enqueued) ';\n\n        if (ptype === MESSAGE.KEXDH_INIT) {\n          if (kexdh === 'group')\n            msgPktType = 'KEXDH_INIT';\n          else if (kexdh[0] === 'e')\n            msgPktType = 'KEXECDH_INIT';\n          else\n            msgPktType = 'KEXDH_GEX_REQUEST';\n        } else if (ptype === MESSAGE.KEXDH_REPLY) {\n          if (kexdh === 'group')\n            msgPktType = 'KEXDH_REPLY';\n          else if (kexdh[0] === 'e')\n            msgPktType = 'KEXECDH_REPLY';\n          else\n            msgPktType = 'KEXDH_GEX_GROUP';\n        } else if (ptype === MESSAGE.KEXDH_GEX_GROUP)\n          msgPktType = 'KEXDH_GEX_GROUP';\n        else if (ptype === MESSAGE.KEXDH_GEX_REPLY)\n          msgPktType = 'KEXDH_GEX_REPLY';\n        else if (ptype === 60) {\n          if (authMethod === 'password')\n            msgPktType = 'USERAUTH_PASSWD_CHANGEREQ';\n          else if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_REQUEST';\n          else if (authMethod === 'publickey')\n            msgPktType = 'USERAUTH_PK_OK';\n          else\n            msgPktType = 'UNKNOWN PACKET 60';\n        } else if (ptype === 61) {\n          if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_RESPONSE';\n          else\n            msgPktType = 'UNKNOWN PACKET 61';\n        }\n\n        if (msgPktType === null)\n          msgPktType = MESSAGE[ptype];\n\n        // Don't write debug output for messages we custom make in parsePacket()\n        if (ptype !== MESSAGE.CHANNEL_OPEN\n            && ptype !== MESSAGE.CHANNEL_REQUEST\n            && ptype !== MESSAGE.CHANNEL_SUCCESS\n            && ptype !== MESSAGE.CHANNEL_FAILURE\n            && ptype !== MESSAGE.CHANNEL_EOF\n            && ptype !== MESSAGE.CHANNEL_CLOSE\n            && ptype !== MESSAGE.CHANNEL_DATA\n            && ptype !== MESSAGE.CHANNEL_EXTENDED_DATA\n            && ptype !== MESSAGE.CHANNEL_WINDOW_ADJUST\n            && ptype !== MESSAGE.DISCONNECT\n            && ptype !== MESSAGE.USERAUTH_REQUEST)\n          debug(msgPacket + msgPktType);\n      }\n\n      // Only parse packet if we are not re-keying or the packet is not a\n      // transport layer packet needed for re-keying\n      if (outstate.status === OUT_READY\n          || ptype <= 4\n          || (ptype >= 20 && ptype <= 49)) {\n        if (parsePacket(this, callback) === false)\n          return;\n\n        if (instate.status === IN_INIT) {\n          // We were reset due to some error/disagreement ?\n          return;\n        }\n      } else if (outstate.status === OUT_REKEYING) {\n        if (instate.rekeyQueue.length === MAX_PACKETS_REKEYING) {\n          debug('DEBUG: Parser: Max incoming re-key queue length reached');\n          this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n          return callback(\n            new Error('Incoming re-key queue length limit reached')\n          );\n        }\n\n        // Make sure to record the sequence number in case we need it later on\n        // when we drain the queue (e.g. unknown packet)\n        var seqno = instate.seqno;\n        if (++instate.seqno > MAX_SEQNO)\n          instate.seqno = 0;\n\n        instate.rekeyQueue.push(seqno, instate.payload);\n      }\n\n      instate.status = IN_PACKETBEFORE;\n      instate.payload = undefined;\n    }\n    if (buffer !== undefined)\n      buffer = undefined;\n  }\n\n  callback();\n};\n\nSSH2Stream.prototype.reset = function(noend) {\n  if (this._state) {\n    var state = this._state;\n    state.incoming.status = IN_INIT;\n    state.outgoing.status = OUT_INIT;\n  } else {\n    this._state = {\n      authsQueue: [],\n      hostkeyFormat: undefined,\n      kex: undefined,\n      kexdh: undefined,\n\n      incoming: {\n        status: IN_INIT,\n        expectedPacket: undefined,\n        search: undefined,\n        greeting: undefined,\n        seqno: 0,\n        pktLen: undefined,\n        padLen: undefined,\n        pktExtra: undefined,\n        payload: undefined,\n        packet: undefined,\n        kexinit: undefined,\n        identRaw: undefined,\n        rekeyQueue: [],\n        ignoreNext: false,\n\n        expect: {\n          amount: undefined,\n          type: undefined,\n          ptr: 0,\n          buf: undefined\n        },\n\n        decrypt: {\n          instance: false,\n          size: 8,\n          isGCM: false,\n          iv: undefined, // GCM\n          key: undefined, // GCM\n          buf: undefined,\n          type: undefined\n        },\n\n        hmac: {\n          size: undefined,\n          key: undefined,\n          buf: undefined,\n          bufCompute: new Buffer(9),\n          type: false\n        },\n\n        decompress: {\n          instance: false,\n          type: false\n        }\n      },\n\n      outgoing: {\n        status: OUT_INIT,\n        seqno: 0,\n        bufSeqno: new Buffer(4),\n        rekeyQueue: [],\n        kexinit: undefined,\n        kexsecret: undefined,\n        pubkey: undefined,\n        exchangeHash: undefined,\n        sessionId: undefined,\n        sentNEWKEYS: false,\n\n        encrypt: {\n          instance: false,\n          size: 8,\n          isGCM: false,\n          iv: undefined, // GCM\n          key: undefined, // GCM\n          type: undefined\n        },\n\n        hmac: {\n          size: undefined,\n          key: undefined,\n          buf: undefined,\n          type: false\n        },\n\n        compress: {\n          instance: false,\n          type: false\n        }\n      }\n    };\n  }\n  if (!noend) {\n    if (this.readable)\n      this.push(null);\n  }\n};\n\n// Common methods\n// Global\nSSH2Stream.prototype.disconnect = function(reason) {\n  /*\n    byte      SSH_MSG_DISCONNECT\n    uint32    reason code\n    string    description in ISO-10646 UTF-8 encoding\n    string    language tag\n  */\n  var buf = new Buffer(1 + 4 + 4 + 4);\n\n  buf.fill(0);\n  buf[0] = MESSAGE.DISCONNECT;\n\n  if (DISCONNECT_REASON[reason] === undefined)\n    reason = DISCONNECT_REASON.BY_APPLICATION;\n  buf.writeUInt32BE(reason, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing DISCONNECT ('\n             + DISCONNECT_REASON[reason]\n             + ')');\n  send(this, buf);\n  this.reset();\n\n  return false;\n};\nSSH2Stream.prototype.ping = function() {\n  this.debug('DEBUG: Outgoing: Writing ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n  return send(this, PING_PACKET);\n};\nSSH2Stream.prototype.rekey = function() {\n  var status = this._state.outgoing.status;\n  if (status === OUT_REKEYING)\n    throw new Error('A re-key is already in progress');\n  else if (status !== OUT_READY)\n    throw new Error('Cannot re-key yet');\n\n  this.debug('DEBUG: Outgoing: Starting re-key');\n  return KEXINIT(this);\n};\n\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.requestSuccess = function(data) {\n  var buf;\n  if (Buffer.isBuffer(data)) {\n    buf = new Buffer(1 + data.length);\n\n    buf[0] = MESSAGE.REQUEST_SUCCESS;\n\n    data.copy(buf, 1);\n  } else\n    buf = REQUEST_SUCCESS_PACKET;\n\n  this.debug('DEBUG: Outgoing: Writing REQUEST_SUCCESS');\n  return send(this, buf);\n};\nSSH2Stream.prototype.requestFailure = function() {\n  this.debug('DEBUG: Outgoing: Writing REQUEST_FAILURE');\n  return send(this, REQUEST_FAILURE_PACKET);\n};\nSSH2Stream.prototype.channelSuccess = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_SUCCESS;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_SUCCESS (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelFailure = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_FAILURE;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_FAILURE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelEOF = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_EOF;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EOF (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelClose = function(chan) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_CLOSE;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_CLOSE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelWindowAdjust = function(chan, amount) {\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(amount, 5, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_WINDOW_ADJUST ('\n             + chan\n             + ', '\n             + amount\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelData = function(chan, data) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = new Buffer(1 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_DATA;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(dataLen, 5, true);\n  if (dataIsBuffer)\n    data.copy(buf, 9);\n  else\n    buf.write(data, 9, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelExtData = function(chan, data, type) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = new Buffer(1 + 4 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_EXTENDED_DATA;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(type, 5, true);\n\n  buf.writeUInt32BE(dataLen, 9, true);\n  if (dataIsBuffer)\n    data.copy(buf, 13);\n  else\n    buf.write(data, 13, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EXTENDED_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenConfirm = function(remoteChan, localChan,\n                                                   initWindow, maxPacket) {\n  var buf = new Buffer(1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n\n  buf.writeUInt32BE(remoteChan, 1, true);\n\n  buf.writeUInt32BE(localChan, 5, true);\n\n  buf.writeUInt32BE(initWindow, 9, true);\n\n  buf.writeUInt32BE(maxPacket, 13, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_CONFIRMATION (r:'\n             + remoteChan\n             + ', l:'\n             + localChan\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenFail = function(remoteChan, reason, desc,\n                                                lang) {\n  if (typeof desc !== 'string')\n    desc = '';\n  if (typeof lang !== 'string')\n    lang = '';\n\n  var descLen = Buffer.byteLength(desc);\n  var langLen = Buffer.byteLength(lang);\n  var p = 9;\n  var buf = new Buffer(1 + 4 + 4 + 4 + descLen + 4 + langLen);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_FAILURE;\n\n  buf.writeUInt32BE(remoteChan, 1, true);\n\n  buf.writeUInt32BE(reason, 5, true);\n\n  buf.writeUInt32BE(descLen, p, true);\n  p += 4;\n  if (descLen) {\n    buf.write(desc, p, descLen, 'utf8');\n    p += descLen;\n  }\n\n  buf.writeUInt32BE(langLen, p, true);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_FAILURE ('\n             + remoteChan\n             + ')');\n  return send(this, buf);\n};\n\n// Client-specific methods\n// Global\nSSH2Stream.prototype.service = function(svcName) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var svcNameLen = Buffer.byteLength(svcName);\n  var buf = new Buffer(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_REQUEST;\n\n  buf.writeUInt32BE(svcNameLen, 1, true);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_REQUEST (' + svcName + ')');\n  return send(this, buf);\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.tcpipForward = function(bindAddr, bindPort, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = new Buffer(1 + 4 + 13 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(13, 1, true);\n  buf.write('tcpip-forward', 5, 13, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(addrlen, 19, true);\n  buf.write(bindAddr, 23, addrlen, 'ascii');\n\n  buf.writeUInt32BE(bindPort, 23 + addrlen, true);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.cancelTcpipForward = function(bindAddr, bindPort,\n                                                   wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = new Buffer(1 + 4 + 20 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(20, 1, true);\n  buf.write('cancel-tcpip-forward', 5, 20, 'ascii');\n\n  buf[25] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(addrlen, 26, true);\n  buf.write(bindAddr, 30, addrlen, 'ascii');\n\n  buf.writeUInt32BE(bindPort, 30 + addrlen, true);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_streamLocalForward = function(socketPath,\n                                                           wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(pathlen);\n  var buf = new Buffer(1 + 4 + 31 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(31, 1, true);\n  buf.write('streamlocal-forward@openssh.com', 5, 31, 'ascii');\n\n  buf[36] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(pathlen, 37, true);\n  buf.write(socketPath, 41, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_cancelStreamLocalForward = function(socketPath,\n                                                                 wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(pathlen);\n  var buf = new Buffer(1 + 4 + 38 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(38, 1, true);\n  buf.write('cancel-streamlocal-forward@openssh.com', 5, 38, 'ascii');\n\n  buf[43] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(pathlen, 44, true);\n  buf.write(socketPath, 48, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.directTcpip = function(chan, initWindow, maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var srclen = Buffer.byteLength(cfg.srcIP);\n  var dstlen = Buffer.byteLength(cfg.dstIP);\n  var p = 29;\n  var buf = new Buffer(1 + 4 + 12 + 4 + 4 + 4 + 4 + srclen + 4 + 4 + dstlen\n                       + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(12, 1, true);\n  buf.write('direct-tcpip', 5, 12, 'ascii');\n\n  buf.writeUInt32BE(chan, 17, true);\n\n  buf.writeUInt32BE(initWindow, 21, true);\n\n  buf.writeUInt32BE(maxPacket, 25, true);\n\n  buf.writeUInt32BE(dstlen, p, true);\n  buf.write(cfg.dstIP, p += 4, dstlen, 'ascii');\n\n  buf.writeUInt32BE(cfg.dstPort, p += dstlen, true);\n\n  buf.writeUInt32BE(srclen, p += 4, true);\n  buf.write(cfg.srcIP, p += 4, srclen, 'ascii');\n\n  buf.writeUInt32BE(cfg.srcPort, p += srclen, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_directStreamLocal = function(chan, initWindow,\n                                                          maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var p = 47;\n  var buf = new Buffer(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathlen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(30, 1, true);\n  buf.write('direct-streamlocal@openssh.com', 5, 30, 'ascii');\n\n  buf.writeUInt32BE(chan, 35, true);\n\n  buf.writeUInt32BE(initWindow, 39, true);\n\n  buf.writeUInt32BE(maxPacket, 43, true);\n\n  buf.writeUInt32BE(pathlen, p, true);\n  buf.write(cfg.socketPath, p += 4, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_noMoreSessions = function(wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var buf = new Buffer(1 + 4 + 28 + 1);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  buf.writeUInt32BE(28, 1, true);\n  buf.write('no-more-sessions@openssh.com', 5, 28, 'ascii');\n\n  buf[33] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.session = function(chan, initWindow, maxPacket) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 7 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(7, 1, true);\n  buf.write('session', 5, 7, 'ascii');\n\n  buf.writeUInt32BE(chan, 12, true);\n\n  buf.writeUInt32BE(initWindow, 16, true);\n\n  buf.writeUInt32BE(maxPacket, 20, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', session)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.windowChange = function(chan, rows, cols, height, width) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(13, 5, true);\n  buf.write('window-change', 9, 13, 'ascii');\n\n  buf[22] = 0;\n\n  buf.writeUInt32BE(cols, 23, true);\n\n  buf.writeUInt32BE(rows, 27, true);\n\n  buf.writeUInt32BE(width, 31, true);\n\n  buf.writeUInt32BE(height, 35, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', window-change)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.pty = function(chan, rows, cols, height,\n                                    width, term, modes, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  if (!term || !term.length)\n    term = 'vt100';\n  if (modes\n      && !Buffer.isBuffer(modes)\n      && !Array.isArray(modes)\n      && typeof modes === 'object')\n    modes = modesToBytes(modes);\n  if (!modes || !modes.length)\n    modes = NO_TERMINAL_MODES_BUFFER;\n\n  var termLen = term.length;\n  var modesLen = modes.length;\n  var p = 21;\n  var buf = new Buffer(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4\n                       + modesLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(7, 5, true);\n  buf.write('pty-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(termLen, 17, true);\n  buf.write(term, 21, termLen, 'utf8');\n\n  buf.writeUInt32BE(cols, p += termLen, true);\n\n  buf.writeUInt32BE(rows, p += 4, true);\n\n  buf.writeUInt32BE(width, p += 4, true);\n\n  buf.writeUInt32BE(height, p += 4, true);\n\n  buf.writeUInt32BE(modesLen, p += 4, true);\n  p += 4;\n  if (Array.isArray(modes)) {\n    for (var i = 0; i < modesLen; ++i)\n      buf[p++] = modes[i];\n  } else if (Buffer.isBuffer(modes)) {\n    modes.copy(buf, p);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', pty-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.shell = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 5 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(5, 5, true);\n  buf.write('shell', 9, 5, 'ascii');\n\n  buf[14] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', shell)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exec = function(chan, cmd, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var cmdlen = (Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd));\n  var buf = new Buffer(1 + 4 + 4 + 4 + 1 + 4 + cmdlen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(4, 5, true);\n  buf.write('exec', 9, 4, 'ascii');\n\n  buf[13] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(cmdlen, 14, true);\n  if (Buffer.isBuffer(cmd))\n    cmd.copy(buf, 18);\n  else\n    buf.write(cmd, 18, cmdlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exec)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.signal = function(chan, signal) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  signal = signal.toUpperCase();\n  if (signal.slice(0, 3) === 'SIG')\n    signal = signal.substring(3);\n\n  if (SIGNALS.indexOf(signal) === -1)\n    throw new Error('Invalid signal: ' + signal);\n\n  var signalLen = signal.length;\n  var buf = new Buffer(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(6, 5, true);\n  buf.write('signal', 9, 6, 'ascii');\n\n  buf[15] = 0;\n\n  buf.writeUInt32BE(signalLen, 16, true);\n  buf.write(signal, 20, signalLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', signal)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.env = function(chan, key, val, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var keyLen = Buffer.byteLength(key);\n  var valLen = (Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val));\n  var buf = new Buffer(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(3, 5, true);\n  buf.write('env', 9, 3, 'ascii');\n\n  buf[12] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(keyLen, 13, true);\n  buf.write(key, 17, keyLen, 'ascii');\n\n  buf.writeUInt32BE(valLen, 17 + keyLen, true);\n  if (Buffer.isBuffer(val))\n    val.copy(buf, 17 + keyLen + 4);\n  else\n    buf.write(val, 17 + keyLen + 4, valLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', env)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11Forward = function(chan, cfg, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var protolen = Buffer.byteLength(cfg.protocol);\n  var cookielen = Buffer.byteLength(cfg.cookie);\n  var buf = new Buffer(1 + 4 + 4 + 7 + 1 + 1 + 4 + protolen + 4 + cookielen\n                       + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(7, 5, true);\n  buf.write('x11-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf[17] = (cfg.single ? 1 : 0);\n\n  buf.writeUInt32BE(protolen, 18, true);\n  var bp = 22;\n  if (Buffer.isBuffer(cfg.protocol))\n    cfg.protocol.copy(buf, bp);\n  else\n    buf.write(cfg.protocol, bp, protolen, 'utf8');\n  bp += protolen;\n\n  buf.writeUInt32BE(cookielen, bp, true);\n  bp += 4;\n  if (Buffer.isBuffer(cfg.cookie))\n    cfg.cookie.copy(buf, bp);\n  else\n    buf.write(cfg.cookie, bp, cookielen, 'utf8');\n  bp += cookielen;\n\n  buf.writeUInt32BE((cfg.screen || 0), bp, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', x11-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.subsystem = function(chan, name, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var buf = new Buffer(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(9, 5, true);\n  buf.write('subsystem', 9, 9, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf.writeUInt32BE(nameLen, 19, true);\n  buf.write(name, 23, nameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', subsystem: '\n             + name\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_agentForward = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 26 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(26, 5, true);\n  buf.write('auth-agent-req@openssh.com', 9, 26, 'ascii');\n\n  buf[35] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', auth-agent-req@openssh.com)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authPassword = function(username, password) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var passLen = Buffer.byteLength(password);\n  var p = 0;\n  var buf = new Buffer(1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 8 // \"password\"\n                       + 1\n                       + 4 + passLen);\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(8, p += 14, true);\n  buf.write('password', p += 4, 8, 'ascii');\n\n  buf[p += 8] = 0;\n\n  buf.writeUInt32BE(passLen, ++p, true);\n  buf.write(password, p += 4, passLen, 'utf8');\n\n  this._state.authsQueue.push('password');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (password)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPK = function(username, pubKey, cbSign) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var pubKeyFullType;\n\n  if (pubKey.public) {\n    pubKeyFullType = pubKey.fulltype;\n    pubKey = pubKey.public;\n  } else {\n    pubKeyFullType = pubKey.toString('ascii',\n                                     4,\n                                     4 + pubKey.readUInt32BE(0, true));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(pubKeyFullType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var p = 0;\n  var buf = new Buffer((cbSign ? 4 + sesLen : 0)\n                       + 1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 9 // \"publickey\"\n                       + 1\n                       + 4 + algoLen\n                       + 4 + pubKeyLen\n                      );\n\n  if (cbSign) {\n    buf.writeUInt32BE(sesLen, p, true);\n    outstate.sessionId.copy(buf, p += 4);\n    buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n  } else\n    buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(9, p += 14, true);\n  buf.write('publickey', p += 4, 9, 'ascii');\n\n  buf[p += 9] = (cbSign ? 1 : 0);\n\n  buf.writeUInt32BE(algoLen, ++p, true);\n  buf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n\n  buf.writeUInt32BE(pubKeyLen, p += algoLen, true);\n  pubKey.copy(buf, p += 4);\n\n  if (!cbSign) {\n    this._state.authsQueue.push('publickey');\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey -- check)');\n    return send(this, buf);\n  }\n\n  cbSign(buf, function(signature) {\n    if (pubKeyFullType === 'ssh-dss') {\n      signature = DSASigBERToBare(signature);\n    } else if (pubKeyFullType !== 'ssh-rsa') {\n      // ECDSA\n      signature = ECDSASigASN1ToSSH(signature);\n    }\n\n    var sigLen = signature.length;\n    var sigbuf = new Buffer(1\n                            + 4 + userLen\n                            + 4 + 14 // \"ssh-connection\"\n                            + 4 + 9 // \"publickey\"\n                            + 1\n                            + 4 + algoLen\n                            + 4 + pubKeyLen\n                            + 4 // 4 + algoLen + 4 + sigLen\n                            + 4 + algoLen\n                            + 4 + sigLen);\n\n    p = 0;\n\n    sigbuf[p] = MESSAGE.USERAUTH_REQUEST;\n\n    sigbuf.writeUInt32BE(userLen, ++p, true);\n    sigbuf.write(username, p += 4, userLen, 'utf8');\n\n    sigbuf.writeUInt32BE(14, p += userLen, true);\n    sigbuf.write('ssh-connection', p += 4, 14, 'ascii');\n\n    sigbuf.writeUInt32BE(9, p += 14, true);\n    sigbuf.write('publickey', p += 4, 9, 'ascii');\n\n    sigbuf[p += 9] = 1;\n\n    sigbuf.writeUInt32BE(algoLen, ++p, true);\n    sigbuf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n\n    sigbuf.writeUInt32BE(pubKeyLen, p += algoLen, true);\n    pubKey.copy(sigbuf, p += 4);\n    sigbuf.writeUInt32BE(4 + algoLen + 4 + sigLen, p += pubKeyLen, true);\n    sigbuf.writeUInt32BE(algoLen, p += 4, true);\n    sigbuf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n    sigbuf.writeUInt32BE(sigLen, p += algoLen, true);\n    signature.copy(sigbuf, p += 4);\n\n    // Servers shouldn't send packet type 60 in response to signed publickey\n    // attempts, but if they do, interpret as type 60.\n    self._state.authsQueue.push('publickey');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authHostbased = function(username, pubKey, hostname,\n                                              userlocal, cbSign) {\n  // TODO: Make DRY by sharing similar code with authPK()\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var pubKeyFullType;\n\n  if (pubKey.public) {\n    pubKeyFullType = pubKey.fulltype;\n    pubKey = pubKey.public;\n  } else {\n    pubKeyFullType = pubKey.toString('ascii',\n                                     4,\n                                     4 + pubKey.readUInt32BE(0, true));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(pubKeyFullType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var hostnameLen = Buffer.byteLength(hostname);\n  var userlocalLen = Buffer.byteLength(userlocal);\n  var p = 0;\n  var buf = new Buffer(4 + sesLen\n                       + 1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 9 // \"hostbased\"\n                       + 4 + algoLen\n                       + 4 + pubKeyLen\n                       + 4 + hostnameLen\n                       + 4 + userlocalLen\n                      );\n\n  buf.writeUInt32BE(sesLen, p, true);\n  outstate.sessionId.copy(buf, p += 4);\n\n  buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(9, p += 14, true);\n  buf.write('hostbased', p += 4, 9, 'ascii');\n\n  buf.writeUInt32BE(algoLen, p += 9, true);\n  buf.write(pubKeyFullType, p += 4, algoLen, 'ascii');\n\n  buf.writeUInt32BE(pubKeyLen, p += algoLen, true);\n  pubKey.copy(buf, p += 4);\n\n  buf.writeUInt32BE(hostnameLen, p += pubKeyLen, true);\n  buf.write(hostname, p += 4, hostnameLen, 'ascii');\n\n  buf.writeUInt32BE(userlocalLen, p += hostnameLen, true);\n  buf.write(userlocal, p += 4, userlocalLen, 'utf8');\n\n  cbSign(buf, function(signature) {\n    if (pubKeyFullType === 'ssh-dss') {\n      signature = DSASigBERToBare(signature);\n    } else if (pubKeyFullType !== 'ssh-rsa') {\n      // ECDSA\n      signature = ECDSASigASN1ToSSH(signature);\n    }\n    var sigLen = signature.length;\n    var sigbuf = new Buffer((buf.length - sesLen) + sigLen);\n\n    buf.copy(sigbuf, 0, 4 + sesLen);\n    sigbuf.writeUInt32BE(sigLen, sigbuf.length - sigLen - 4, true);\n    signature.copy(sigbuf, sigbuf.length - sigLen);\n\n    self._state.authsQueue.push('hostbased');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (hostbased)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authKeyboard = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = new Buffer(1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 20 // \"keyboard-interactive\"\n                       + 4 // no language set\n                       + 4 // no submethods\n                      );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(20, p += 14, true);\n  buf.write('keyboard-interactive', p += 4, 20, 'ascii');\n\n  buf.writeUInt32BE(0, p += 20, true);\n\n  buf.writeUInt32BE(0, p += 4, true);\n\n  this._state.authsQueue.push('keyboard-interactive');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (keyboard-interactive)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authNone = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = new Buffer(1\n                       + 4 + userLen\n                       + 4 + 14 // \"ssh-connection\"\n                       + 4 + 4 // \"none\"\n                      );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  buf.writeUInt32BE(userLen, ++p, true);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  buf.writeUInt32BE(14, p += userLen, true);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  buf.writeUInt32BE(4, p += 14, true);\n  buf.write('none', p += 4, 4, 'ascii');\n\n  this._state.authsQueue.push('none');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (none)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoRes = function(responses) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var responsesLen = 0;\n  var p = 0;\n  var resLen;\n  var len;\n  var i;\n\n  if (responses) {\n    for (i = 0, len = responses.length; i < len; ++i)\n      responsesLen += 4 + Buffer.byteLength(responses[i]);\n  }\n  var buf = new Buffer(1 + 4 + responsesLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n  buf.writeUInt32BE(responses ? responses.length : 0, p, true);\n  if (responses) {\n    p += 4;\n    for (i = 0, len = responses.length; i < len; ++i) {\n      resLen = Buffer.byteLength(responses[i]);\n      buf.writeUInt32BE(resLen, p, true);\n      p += 4;\n      if (resLen) {\n        buf.write(responses[i], p, resLen, 'utf8');\n        p += resLen;\n      }\n    }\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_RESPONSE');\n  return send(this, buf);\n};\n\n// Server-specific methods\n// Global\nSSH2Stream.prototype.serviceAccept = function(svcName) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var svcNameLen = svcName.length;\n  var buf = new Buffer(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_ACCEPT;\n\n  buf.writeUInt32BE(svcNameLen, 1, true);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_ACCEPT (' + svcName + ')');\n  send(this, buf);\n\n  if (this.server && this.banner && svcName === 'ssh-userauth') {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var bannerLen = Buffer.byteLength(this.banner);\n    var packetLen = 1 + 4 + bannerLen + 4;\n    if (packetLen > BUFFER_MAX_LEN) {\n      bannerLen -= 1 + 4 + 4;\n      packetLen -= 1 + 4 + 4;\n    }\n    var packet = new Buffer(packetLen);\n    packet[0] = MESSAGE.USERAUTH_BANNER;\n    packet.writeUInt32BE(bannerLen, 1, true);\n    packet.write(this.banner, 5, bannerLen, 'utf8');\n    packet.fill(0, packetLen - 4); // Empty language tag\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_BANNER');\n    send(this, packet);\n    this.banner = undefined; // Prevent banner from being displayed again\n  }\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.forwardedTcpip = function(chan, initWindow, maxPacket,\n                                               cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n  var remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n  var p = 36 + boundAddrLen;\n  var buf = new Buffer(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4\n                       + remoteAddrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(15, 1, true);\n  buf.write('forwarded-tcpip', 5, 15, 'ascii');\n\n  buf.writeUInt32BE(chan, 20, true);\n\n  buf.writeUInt32BE(initWindow, 24, true);\n\n  buf.writeUInt32BE(maxPacket, 28, true);\n\n  buf.writeUInt32BE(boundAddrLen, 32, true);\n  buf.write(cfg.boundAddr, 36, boundAddrLen, 'ascii');\n\n  buf.writeUInt32BE(cfg.boundPort, p, true);\n\n  buf.writeUInt32BE(remoteAddrLen, p += 4, true);\n  buf.write(cfg.remoteAddr, p += 4, remoteAddrLen, 'ascii');\n\n  buf.writeUInt32BE(cfg.remotePort, p += remoteAddrLen, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11 = function(chan, initWindow, maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var addrLen = Buffer.byteLength(cfg.originAddr);\n  var p = 24 + addrLen;\n  var buf = new Buffer(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(3, 1, true);\n  buf.write('x11', 5, 3, 'ascii');\n\n  buf.writeUInt32BE(chan, 8, true);\n\n  buf.writeUInt32BE(initWindow, 12, true);\n\n  buf.writeUInt32BE(maxPacket, 16, true);\n\n  buf.writeUInt32BE(addrLen, 20, true);\n  buf.write(cfg.originAddr, 24, addrLen, 'ascii');\n\n  buf.writeUInt32BE(cfg.originPort, p, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', x11)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_forwardedStreamLocal = function(chan, initWindow,\n                                                             maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var buf = new Buffer(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathlen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  buf.writeUInt32BE(33, 1, true);\n  buf.write('forwarded-streamlocal@openssh.com', 5, 33, 'ascii');\n\n  buf.writeUInt32BE(chan, 38, true);\n\n  buf.writeUInt32BE(initWindow, 42, true);\n\n  buf.writeUInt32BE(maxPacket, 46, true);\n\n  buf.writeUInt32BE(pathlen, 50, true);\n  buf.write(cfg.socketPath, 54, pathlen, 'utf8');\n\n  buf.writeUInt32BE(0, 54 + pathlen, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitStatus = function(chan, status) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var buf = new Buffer(1 + 4 + 4 + 11 + 1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(11, 5, true);\n  buf.write('exit-status', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  buf.writeUInt32BE(status, 21, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-status)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitSignal = function(chan, name, coreDumped, msg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var msgLen = (msg ? Buffer.byteLength(msg) : 0);\n  var p = 25 + nameLen;\n  var buf = new Buffer(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  buf.writeUInt32BE(chan, 1, true);\n\n  buf.writeUInt32BE(11, 5, true);\n  buf.write('exit-signal', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  buf.writeUInt32BE(nameLen, 21, true);\n  buf.write(name, 25, nameLen, 'utf8');\n\n  buf[p++] = (coreDumped ? 1 : 0);\n\n  buf.writeUInt32BE(msgLen, p, true);\n  p += 4;\n  if (msgLen) {\n    buf.write(msg, p, msgLen, 'utf8');\n    p += msgLen;\n  }\n\n  buf.writeUInt32BE(0, p, true);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-signal)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authFailure = function(authMethods, isPartial) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  var methods;\n\n  if (typeof authMethods === 'boolean') {\n    isPartial = authMethods;\n    authMethods = undefined;\n  }\n\n  if (authMethods) {\n    methods = [];\n    for (var i = 0, len = authMethods.length; i < len; ++i) {\n      if (authMethods[i].toLowerCase() === 'none')\n        continue;\n      methods.push(authMethods[i]);\n    }\n    methods = methods.join(',');\n  } else\n    methods = '';\n\n  var methodsLen = methods.length;\n  var buf = new Buffer(1 + 4 + methodsLen + 1);\n\n  buf[0] = MESSAGE.USERAUTH_FAILURE;\n\n  buf.writeUInt32BE(methodsLen, 1, true);\n  buf.write(methods, 5, methodsLen, 'ascii');\n\n  buf[5 + methodsLen] = (isPartial === true ? 1 : 0);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_FAILURE');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authSuccess = function() {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_SUCCESS');\n  return send(this, USERAUTH_SUCCESS_PACKET);\n};\nSSH2Stream.prototype.authPKOK = function(keyAlgo, key) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length || authsQueue[0] !== 'publickey')\n    throw new Error('\"publickey\" auth not in progress');\n\n  var keyAlgoLen = keyAlgo.length;\n  var keyLen = key.length;\n  var buf = new Buffer(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n  buf[0] = MESSAGE.USERAUTH_PK_OK;\n\n  buf.writeUInt32BE(keyAlgoLen, 1, true);\n  buf.write(keyAlgo, 5, keyAlgoLen, 'ascii');\n\n  buf.writeUInt32BE(keyLen, 5 + keyAlgoLen, true);\n  key.copy(buf, 5 + keyAlgoLen + 4);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PK_OK');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPasswdChg = function(prompt, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptLen = Buffer.byteLength(prompt);\n  var langLen = lang ? lang.length : 0;\n  var p = 0;\n  var buf = new Buffer(1 + 4 + promptLen + 4 + langLen);\n\n  buf[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n\n  buf.writeUInt32BE(promptLen, ++p, true);\n  buf.write(prompt, p += 4, promptLen, 'utf8');\n\n  buf.writeUInt32BE(langLen, p += promptLen, true);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PASSWD_CHANGEREQ');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoReq = function(name, instructions, prompts) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptsLen = 0;\n  var nameLen = name ? Buffer.byteLength(name) : 0;\n  var instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n  var p = 0;\n  var promptLen;\n  var prompt;\n  var len;\n  var i;\n\n  for (i = 0, len = prompts.length; i < len; ++i)\n    promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n  var buf = new Buffer(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_REQUEST;\n\n  buf.writeUInt32BE(nameLen, p, true);\n  p += 4;\n  if (name) {\n    buf.write(name, p, nameLen, 'utf8');\n    p += nameLen;\n  }\n\n  buf.writeUInt32BE(instrLen, p, true);\n  p += 4;\n  if (instructions) {\n    buf.write(instructions, p, instrLen, 'utf8');\n    p += instrLen;\n  }\n\n  buf.writeUInt32BE(0, p, true);\n  p += 4;\n\n  buf.writeUInt32BE(prompts.length, p, true);\n  p += 4;\n  for (i = 0, len = prompts.length; i < len; ++i) {\n    prompt = prompts[i];\n    promptLen = Buffer.byteLength(prompt.prompt);\n    buf.writeUInt32BE(promptLen, p, true);\n    p += 4;\n    if (promptLen) {\n      buf.write(prompt.prompt, p, promptLen, 'utf8');\n      p += promptLen;\n    }\n    buf[p++] = (prompt.echo ? 1 : 0);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_REQUEST');\n  return send(this, buf);\n};\n\n// Shared incoming/parser functions\nfunction onDISCONNECT(self, reason, code, desc, lang) { // Client/Server\n  if (code !== DISCONNECT_REASON.BY_APPLICATION) {\n    var err = new Error(desc || reason);\n    err.code = code;\n    self.emit('error', err);\n  }\n  self.reset();\n}\n\nfunction onKEXINIT(self, init, firstFollows) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  if (outstate.status === OUT_READY) {\n    self.debug('DEBUG: Received re-key request');\n    outstate.status = OUT_REKEYING;\n    outstate.kexinit = undefined;\n    KEXINIT(self, check);\n  } else\n    check();\n\n  function check() {\n    if (check_KEXINIT(self, init, firstFollows) === true) {\n      var isGEX = RE_GEX.test(state.kexdh);\n      if (!self.server) {\n        if (isGEX)\n          KEXDH_GEX_REQ(self);\n        else\n          KEXDH_INIT(self);\n      } else {\n        if (isGEX)\n          state.incoming.expectedPacket = 'KEXDH_GEX_REQ';\n        else\n          state.incoming.expectedPacket = 'KEXDH_INIT';\n      }\n    }\n  }\n}\n\nfunction check_KEXINIT(self, init, firstFollows) {\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var serverList;\n  var clientList;\n  var val;\n  var len;\n  var i;\n\n  debug('DEBUG: Comparing KEXINITs ...');\n\n  var algos = self.config.algorithms;\n\n  var kexList = algos.kex;\n  if (self.remoteBugs & BUGS.BAD_DHGEX) {\n    var copied = false;\n    for (var j = kexList.length - 1; j >= 0; --j) {\n      if (kexList[j].indexOf('group-exchange') !== -1) {\n        if (!copied) {\n          kexList = kexList.slice();\n          copied = true;\n        }\n        kexList.splice(j, 1);\n      }\n    }\n  }\n\n  debug('DEBUG: (local) KEX algorithms: ' + kexList);\n  debug('DEBUG: (remote) KEX algorithms: ' + init.algorithms.kex);\n  if (self.server) {\n    serverList = kexList;\n    clientList = init.algorithms.kex;\n  } else {\n    serverList = init.algorithms.kex;\n    clientList = kexList;\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching key exchange algorithm');\n    var err = new Error('Handshake failed: no matching key exchange algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var kex_algorithm = clientList[i];\n  debug('DEBUG: KEX algorithm: ' + kex_algorithm);\n  if (firstFollows\n      && (!init.algorithms.kex.length\n          || kex_algorithm !== init.algorithms.kex[0])) {\n    // Ignore next incoming packet, it was a wrong first guess at KEX algorithm\n    instate.ignoreNext = true;\n  }\n\n  debug('DEBUG: (local) Host key formats: ' + algos.serverHostKey);\n  debug('DEBUG: (remote) Host key formats: ' + init.algorithms.srvHostKey);\n  if (self.server) {\n    serverList = algos.serverHostKey;\n    clientList = init.algorithms.srvHostKey;\n  } else {\n    serverList = init.algorithms.srvHostKey;\n    clientList = algos.serverHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching host key format');\n    var err = new Error('Handshake failed: no matching host key format');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  state.hostkeyFormat = clientList[i];\n  debug('DEBUG: Host key format: ' + state.hostkeyFormat);\n\n  debug('DEBUG: (local) Client->Server ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Client->Server ciphers: '\n        + init.algorithms.cs.encrypt);\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.cs.encrypt;\n  } else {\n    serverList = init.algorithms.cs.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server cipher');\n    var err = new Error('Handshake failed: no matching client->server cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server) {\n    val = instate.decrypt.type = clientList[i];\n    instate.decrypt.isGCM = RE_GCM.test(val);\n  } else {\n    val = outstate.encrypt.type = clientList[i];\n    outstate.encrypt.isGCM = RE_GCM.test(val);\n  }\n  debug('DEBUG: Client->Server Cipher: ' + val);\n\n  debug('DEBUG: (local) Server->Client ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Server->Client ciphers: '\n        + (init.algorithms.sc.encrypt));\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.sc.encrypt;\n  } else {\n    serverList = init.algorithms.sc.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client cipher');\n    var err = new Error('Handshake failed: no matching server->client cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server) {\n    val = outstate.encrypt.type = clientList[i];\n    outstate.encrypt.isGCM = RE_GCM.test(val);\n  } else {\n    val = instate.decrypt.type = clientList[i];\n    instate.decrypt.isGCM = RE_GCM.test(val);\n  }\n  debug('DEBUG: Server->Client Cipher: ' + val);\n\n  debug('DEBUG: (local) Client->Server HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Client->Server HMAC algorithms: '\n        + init.algorithms.cs.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.cs.mac;\n  } else {\n    serverList = init.algorithms.cs.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable client->server hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server HMAC algorithm');\n    var err = new Error('Handshake failed: no matching client->server HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.hmac.type = clientList[i];\n  else\n    val = outstate.hmac.type = clientList[i];\n  debug('DEBUG: Client->Server HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Server->Client HMAC algorithms: '\n        + init.algorithms.sc.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.sc.mac;\n  } else {\n    serverList = init.algorithms.sc.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable server->client hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client HMAC algorithm');\n    var err = new Error('Handshake failed: no matching server->client HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.hmac.type = clientList[i];\n  else\n    val = instate.hmac.type = clientList[i];\n  debug('DEBUG: Server->Client HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Client->Server compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Client->Server compression algorithms: '\n        + init.algorithms.cs.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.cs.compress;\n  } else {\n    serverList = init.algorithms.cs.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server compression algorithm');\n    var err = new Error('Handshake failed: no matching client->server '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.decompress.type = clientList[i];\n  else\n    val = outstate.compress.type = clientList[i];\n  debug('DEBUG: Client->Server compression algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Server->Client compression algorithms: '\n        + init.algorithms.sc.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.sc.compress;\n  } else {\n    serverList = init.algorithms.sc.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client compression algorithm');\n    var err = new Error('Handshake failed: no matching server->client '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.compress.type = clientList[i];\n  else\n    val = instate.decompress.type = clientList[i];\n  debug('DEBUG: Server->Client compression algorithm: ' + val);\n\n  switch (kex_algorithm) {\n    case 'diffie-hellman-group1-sha1':\n      state.kexdh = 'group';\n      state.kex = crypto.getDiffieHellman('modp2');\n      break;\n    case 'diffie-hellman-group14-sha1':\n      state.kexdh = 'group';\n      state.kex = crypto.getDiffieHellman('modp14');\n      break;\n    case 'ecdh-sha2-nistp256':\n      state.kexdh = 'ec-sha256';\n      state.kex = crypto.createECDH(SSH_TO_OPENSSL[kex_algorithm]);\n      break;\n    case 'ecdh-sha2-nistp384':\n      state.kexdh = 'ec-sha384';\n      state.kex = crypto.createECDH(SSH_TO_OPENSSL[kex_algorithm]);\n      break;\n    case 'ecdh-sha2-nistp521':\n      state.kexdh = 'ec-sha512';\n      state.kex = crypto.createECDH(SSH_TO_OPENSSL[kex_algorithm]);\n      break;\n    default:\n      if (kex_algorithm === 'diffie-hellman-group-exchange-sha1')\n        state.kexdh = 'gex-sha1';\n      else if (kex_algorithm === 'diffie-hellman-group-exchange-sha256')\n        state.kexdh = 'gex-sha256';\n      // Reset kex object if DH group exchange is selected on re-key and DH\n      // group exchange was used before the re-key. This ensures that we send\n      // the right DH packet after the KEXINIT exchange\n      state.kex = undefined;\n  }\n\n  if (state.kex) {\n    outstate.pubkey = state.kex.generateKeys();\n    var idx = 0;\n    len = outstate.pubkey.length;\n    while (outstate.pubkey[idx] === 0x00) {\n      ++idx;\n      --len;\n    }\n    if (outstate.pubkey[idx] & 0x80) {\n      var key = new Buffer(len + 1);\n      key[0] = 0;\n      outstate.pubkey.copy(key, 1, idx);\n      outstate.pubkey = key;\n    }\n  }\n\n  return true;\n}\n\nfunction onKEXDH_GEX_GROUP(self, prime, gen) {\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  state.kex = crypto.createDiffieHellman(prime, gen);\n  outstate.pubkey = state.kex.generateKeys();\n  var idx = 0;\n  var len = outstate.pubkey.length;\n  while (outstate.pubkey[idx] === 0x00) {\n    ++idx;\n    --len;\n  }\n  if (outstate.pubkey[idx] & 0x80) {\n    var key = new Buffer(len + 1);\n    key[0] = 0;\n    outstate.pubkey.copy(key, 1, idx);\n    outstate.pubkey = key;\n  }\n  KEXDH_INIT(self);\n}\n\nfunction onKEXDH_INIT(self, e) { // Server\n  KEXDH_REPLY(self, e);\n}\n\nfunction onKEXDH_REPLY(self, info, verifiedHost) { // Client\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var len;\n  var i;\n\n  if (verifiedHost === undefined) {\n    instate.expectedPacket = 'NEWKEYS';\n    outstate.sentNEWKEYS = false;\n\n    debug('DEBUG: Checking host key format');\n    // Ensure all host key formats agree\n    var hostkey_format = readString(info.hostkey, 0, 'ascii', self);\n    if (hostkey_format === false)\n      return false;\n    if (info.hostkey_format !== state.hostkeyFormat\n        || info.hostkey_format !== hostkey_format) {\n      // Expected and actual server host key format do not match!\n      debug('DEBUG: Host key format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: host key format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n\n    debug('DEBUG: Checking signature format');\n    // Ensure signature formats agree\n    var sig_format = readString(info.sig, 0, 'ascii', self);\n    if (sig_format === false)\n      return false;\n    if (info.sig_format !== sig_format) {\n      debug('DEBUG: Signature format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: signature format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  // Verify the host fingerprint first if needed\n  if (outstate.status === OUT_INIT) {\n    if (verifiedHost === undefined) {\n      debug('DEBUG: Verifying host fingerprint');\n      var sync = true;\n      var emitted = self.emit('fingerprint', info.hostkey, function(permitted) {\n        // Prevent multiple calls to this callback\n        if (verifiedHost !== undefined)\n          return;\n        verifiedHost = !!permitted;\n        if (!sync) {\n          // Continue execution by re-entry\n          onKEXDH_REPLY(self, info, verifiedHost);\n        }\n      });\n      sync = false;\n      // Support async calling of verification callback\n      if (emitted && verifiedHost === undefined)\n        return;\n    }\n    if (verifiedHost === undefined)\n      debug('DEBUG: Host accepted by default (no verification)');\n    else if (verifiedHost === true)\n      debug('DEBUG: Host accepted (verified)');\n    else {\n      debug('DEBUG: Host denied via fingerprint verification');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: '\n                          + 'host fingerprint verification failed');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  var slicepos = -1;\n  for (i = 0, len = info.pubkey.length; i < len; ++i) {\n    if (info.pubkey[i] === 0)\n      ++slicepos;\n    else\n      break;\n  }\n  if (slicepos > -1)\n    info.pubkey = info.pubkey.slice(slicepos + 1);\n  info.secret = tryComputeSecret(state.kex, info.pubkey);\n  if (info.secret instanceof Error) {\n    info.secret.message = 'Error while computing DH secret ('\n                          + state.kexdh + '): '\n                          + info.secret.message;\n    info.secret.level = 'handshake';\n    self.emit('error', info.secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hashAlgo;\n  if (state.kexdh === 'group')\n    hashAlgo = 'sha1';\n  else\n    hashAlgo = RE_KEX_HASH.exec(state.kexdh)[1];\n  var hash = crypto.createHash(hashAlgo);\n\n  var len_ident = Buffer.byteLength(self.config.ident);\n  var len_sident = Buffer.byteLength(instate.identRaw);\n  var len_init = outstate.kexinit.length;\n  var len_sinit = instate.kexinit.length;\n  var len_hostkey = info.hostkey.length;\n  var len_pubkey = outstate.pubkey.length;\n  var len_spubkey = info.pubkey.length;\n  var len_secret = info.secret.length;\n\n  var idx_pubkey = 0;\n  var idx_spubkey = 0;\n  var idx_secret = 0;\n\n  while (outstate.pubkey[idx_pubkey] === 0x00) {\n    ++idx_pubkey;\n    --len_pubkey;\n  }\n  while (info.pubkey[idx_spubkey] === 0x00) {\n    ++idx_spubkey;\n    --len_spubkey;\n  }\n  while (info.secret[idx_secret] === 0x00) {\n    ++idx_secret;\n    --len_secret;\n  }\n  if (outstate.pubkey[idx_pubkey] & 0x80)\n    ++len_pubkey;\n  if (info.pubkey[idx_spubkey] & 0x80)\n    ++len_spubkey;\n  if (info.secret[idx_secret] & 0x80)\n    ++len_secret;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var isGEX = RE_GEX.test(state.kexdh);\n  var len_gex_prime = 0;\n  var len_gex_gen = 0;\n  var idx_gex_prime = 0;\n  var idx_gex_gen = 0;\n  var gex_prime;\n  var gex_gen;\n  if (isGEX) {\n    gex_prime = state.kex.getPrime();\n    gex_gen = state.kex.getGenerator();\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    while (gex_prime[idx_gex_prime] === 0x00) {\n      ++idx_gex_prime;\n      --len_gex_prime;\n    }\n    while (gex_gen[idx_gex_gen] === 0x00) {\n      ++idx_gex_gen;\n      --len_gex_gen;\n    }\n    if (gex_prime[idx_gex_prime] & 0x80)\n      ++len_gex_prime;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      ++len_gex_gen;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n\n  var bp = 0;\n  var exchangeBuf = new Buffer(exchangeBufLen);\n\n  exchangeBuf.writeUInt32BE(len_ident, bp, true);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  exchangeBuf.writeUInt32BE(len_sident, bp, true);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  exchangeBuf.writeUInt32BE(len_init, bp, true);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  outstate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_sinit, bp, true);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  instate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_hostkey, bp, true);\n  bp += 4;\n  info.hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (isGEX) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    exchangeBuf.writeUInt32BE(len_gex_prime, bp, true);\n    bp += 4;\n    if (gex_prime[idx_gex_prime] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_prime.copy(exchangeBuf, bp, idx_gex_prime); // p\n    bp += len_gex_prime - (gex_prime[idx_gex_prime] & 0x80 ? 1 : 0);\n\n    exchangeBuf.writeUInt32BE(len_gex_gen, bp, true);\n    bp += 4;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_gen.copy(exchangeBuf, bp, idx_gex_gen); // g\n    bp += len_gex_gen - (gex_gen[idx_gex_gen] & 0x80 ? 1 : 0);\n  }\n\n  exchangeBuf.writeUInt32BE(len_pubkey, bp, true);\n  bp += 4;\n  if (outstate.pubkey[idx_pubkey] & 0x80)\n    exchangeBuf[bp++] = 0;\n  outstate.pubkey.copy(exchangeBuf, bp, idx_pubkey); // e\n  bp += len_pubkey - (outstate.pubkey[idx_pubkey] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_spubkey, bp, true);\n  bp += 4;\n  if (info.pubkey[idx_spubkey] & 0x80)\n    exchangeBuf[bp++] = 0;\n  info.pubkey.copy(exchangeBuf, bp, idx_spubkey); // f\n  bp += len_spubkey - (info.pubkey[idx_spubkey] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_secret, bp, true);\n  bp += 4;\n  if (info.secret[idx_secret] & 0x80)\n    exchangeBuf[bp++] = 0;\n  info.secret.copy(exchangeBuf, bp, idx_secret); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  var rawsig = readString(info.sig, info.sig._pos, self); // s\n  if (rawsig === false)\n    return false;\n\n  var keyAlgo;\n  switch (info.sig_format) {\n    case 'ssh-rsa':\n      keyAlgo = 'RSA-SHA1';\n      break;\n    case 'ssh-dss':\n      keyAlgo = 'DSA-SHA1';\n      break;\n    case 'ecdsa-sha2-nistp256':\n      keyAlgo = 'sha256';\n      break;\n    case 'ecdsa-sha2-nistp384':\n      keyAlgo = 'sha384';\n      break;\n    case 'ecdsa-sha2-nistp521':\n      keyAlgo = 'sha512';\n      break;\n    default:\n      debug('DEBUG: Signature format unsupported: ' + info.sig_format);\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: signature format unsupported: '\n                          + info.sig_format);\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n  }\n  var verifier = crypto.createVerify(keyAlgo);\n  verifier.update(outstate.exchangeHash);\n\n  var asn1KeyBuf;\n  if (keyAlgo === 'RSA-SHA1') {\n    asn1KeyBuf = RSAKeySSHToASN1(info.hostkey, self);\n  } else if (keyAlgo === 'DSA-SHA1') {\n    asn1KeyBuf = DSAKeySSHToASN1(info.hostkey, self);\n    rawsig = DSASigBareToBER(rawsig);\n  } else {\n    // ECDSA\n    asn1KeyBuf = ECDSAKeySSHToASN1(info.hostkey, self);\n    rawsig = ECDSASigSSHToASN1(rawsig, self);\n  }\n\n  if (!asn1KeyBuf || !rawsig)\n    return false;\n\n  debug('DEBUG: Verifying signature');\n\n  var b64key = asn1KeyBuf.toString('base64').replace(/(.{64})/g, '$1\\n');\n  var fullkey = '-----BEGIN PUBLIC KEY-----\\n'\n                + b64key\n                + (b64key[b64key.length - 1] === '\\n' ? '' : '\\n')\n                + '-----END PUBLIC KEY-----';\n\n  var verified = verifier.verify(fullkey, rawsig);\n\n  if (!verified) {\n    debug('DEBUG: Signature verification failed');\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    self.reset();\n    var err = new Error('Handshake failed: signature verification failed');\n    err.level = 'handshake';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = info.secret;\n\n  debug('DEBUG: Outgoing: Writing NEWKEYS');\n  if (outstate.status === OUT_REKEYING)\n    send(self, NEWKEYS_PACKET, undefined, true);\n  else\n    send(self, NEWKEYS_PACKET);\n  outstate.sentNEWKEYS = true;\n\n  if (verifiedHost !== undefined && instate.expectedPacket === undefined) {\n    // We received NEWKEYS while we were waiting for the fingerprint\n    // verification callback to be called. In this case we have to re-execute\n    // onNEWKEYS to finish the handshake.\n    onNEWKEYS(self);\n  }\n}\n\nfunction onNEWKEYS(self) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n\n  instate.expectedPacket = undefined;\n\n  if (!outstate.sentNEWKEYS)\n    return;\n\n  var idx_secret = 0;\n  var len = outstate.kexsecret.length;\n  while (outstate.kexsecret[idx_secret] === 0x00) {\n    ++idx_secret;\n    --len;\n  }\n\n  var blocklen = 8;\n  var keylen = 0;\n  var p = 0;\n\n  var dhHashAlgo;\n  if (state.kexdh === 'group')\n    dhHashAlgo = 'sha1';\n  else\n    dhHashAlgo = RE_KEX_HASH.exec(state.kexdh)[1];\n\n  var len_secret = (outstate.kexsecret[idx_secret] & 0x80 ? 1 : 0) + len;\n  var secret = new Buffer(4 + len_secret);\n  var iv;\n  var key;\n\n  // Whenever the client sends a new authentication request, it is enqueued\n  // here.  Once the request is resolved (success, fail, or PK_OK),\n  // dequeue.  Whatever is at the front of the queue determines how we\n  // interpret packet type 60.\n  state.authsQueue = [];\n\n  secret.writeUInt32BE(len_secret, p, true);\n  p += 4;\n  if (outstate.kexsecret[idx_secret] & 0x80)\n    secret[p++] = 0;\n  outstate.kexsecret.copy(secret, p, idx_secret);\n  outstate.kexsecret = undefined;\n  if (!isStreamCipher(outstate.encrypt.type)) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'A' : 'B', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    switch (outstate.encrypt.type) {\n      case 'aes128-gcm':\n      case 'aes256-gcm':\n      case 'aes128-gcm@openssh.com':\n      case 'aes256-gcm@openssh.com':\n        blocklen = 12;\n      break;\n      case 'aes256-cbc':\n      case 'aes192-cbc':\n      case 'aes128-cbc':\n      case 'aes256-ctr':\n      case 'aes192-ctr':\n      case 'aes128-ctr':\n        blocklen = 16;\n    }\n    outstate.encrypt.size = blocklen;\n    while (blocklen > iv.length) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    iv = iv.slice(0, blocklen);\n  } else {\n    outstate.encrypt.size = blocklen;\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n  switch (outstate.encrypt.type) {\n    case 'aes256-gcm':\n    case 'aes256-gcm@openssh.com':\n    case 'aes256-cbc':\n    case 'aes256-ctr':\n    case 'arcfour256':\n      keylen = 32;\n      break;\n    case '3des-cbc':\n    case '3des-ctr':\n    case 'aes192-cbc':\n    case 'aes192-ctr':\n      keylen = 24;\n      break;\n    case 'aes128-gcm':\n    case 'aes128-gcm@openssh.com':\n    case 'aes128-cbc':\n    case 'aes128-ctr':\n    case 'cast128-cbc':\n    case 'blowfish-cbc':\n    case 'arcfour':\n    case 'arcfour128':\n      keylen = 16;\n      break;\n  }\n\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'C' : 'D', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (keylen > key.length) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  key = key.slice(0, keylen);\n\n  if (outstate.encrypt.isGCM) {\n    outstate.encrypt.size = 16;\n    outstate.encrypt.iv = iv;\n    outstate.encrypt.key = key;\n    outstate.encrypt.instance = true;\n  } else {\n    var cipherAlgo = SSH_TO_OPENSSL[outstate.encrypt.type];\n    outstate.encrypt.instance = crypto.createCipheriv(cipherAlgo, key, iv);\n    outstate.encrypt.instance.setAutoPadding(false);\n  }\n\n  // And now for decrypting ...\n\n  blocklen = 8;\n  keylen = 0;\n  if (!isStreamCipher(instate.decrypt.type)) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'B' : 'A', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    switch (instate.decrypt.type) {\n      case 'aes128-gcm':\n      case 'aes256-gcm':\n      case 'aes128-gcm@openssh.com':\n      case 'aes256-gcm@openssh.com':\n        blocklen = 12;\n      break;\n      case 'aes256-cbc':\n      case 'aes192-cbc':\n      case 'aes128-cbc':\n      case 'aes256-ctr':\n      case 'aes192-ctr':\n      case 'aes128-ctr':\n        blocklen = 16;\n    }\n    if (instate.decrypt.isGCM)\n      instate.decrypt.size = 16;\n    else\n      instate.decrypt.size = blocklen;\n    while (blocklen > iv.length) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    iv = iv.slice(0, blocklen);\n  } else {\n    instate.decrypt.size = blocklen;\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n\n  // Create a reusable buffer for decryption purposes\n  instate.decrypt.buf = new Buffer(instate.decrypt.size);\n\n  switch (instate.decrypt.type) {\n    case 'aes256-gcm':\n    case 'aes256-gcm@openssh.com':\n    case 'aes256-cbc':\n    case 'aes256-ctr':\n    case 'arcfour256':\n      keylen = 32;\n      break;\n    case '3des-cbc':\n    case '3des-ctr':\n    case 'aes192-cbc':\n    case 'aes192-ctr':\n      keylen = 24;\n      break;\n    case 'aes128-gcm':\n    case 'aes128-gcm@openssh.com':\n    case 'aes128-cbc':\n    case 'aes128-ctr':\n    case 'cast128-cbc':\n    case 'blowfish-cbc':\n    case 'arcfour':\n    case 'arcfour128':\n      keylen = 16;\n      break;\n  }\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'D' : 'C', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (keylen > key.length) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  key = key.slice(0, keylen);\n\n  var decipherAlgo = SSH_TO_OPENSSL[instate.decrypt.type];\n  instate.decrypt.instance = crypto.createDecipheriv(decipherAlgo, key, iv);\n  instate.decrypt.instance.setAutoPadding(false);\n  instate.decrypt.iv = iv;\n  instate.decrypt.key = key;\n\n  /* The \"arcfour128\" algorithm is the RC4 cipher, as described in\n     [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream\n     generated by the cipher MUST be discarded, and the first byte of the\n     first encrypted packet MUST be encrypted using the 1537th byte of\n     keystream.\n\n     -- http://tools.ietf.org/html/rfc4345#section-4 */\n  var emptyBuf;\n  if (outstate.encrypt.type.substr(0, 7) === 'arcfour') {\n    emptyBuf = new Buffer(1536);\n    emptyBuf.fill(0);\n    outstate.encrypt.instance.update(emptyBuf);\n  }\n  if (instate.decrypt.type.substr(0, 7) === 'arcfour') {\n    emptyBuf = new Buffer(1536);\n    emptyBuf.fill(0);\n    instate.decrypt.instance.update(emptyBuf);\n  }\n\n  var createKeyLen = 0;\n  var checkKeyLen = 0;\n  switch (outstate.hmac.type) {\n    case 'hmac-ripemd160':\n    case 'hmac-sha1':\n      createKeyLen = 20;\n      outstate.hmac.size = 20;\n      break;\n    case 'hmac-sha1-96':\n      createKeyLen = 20;\n      outstate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-256':\n      createKeyLen = 32;\n      outstate.hmac.size = 32;\n      break;\n    case 'hmac-sha2-256-96':\n      createKeyLen = 32;\n      outstate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-512':\n      createKeyLen = 64;\n      outstate.hmac.size = 64;\n      break;\n    case 'hmac-sha2-512-96':\n      createKeyLen = 64;\n      outstate.hmac.size = 12;\n      break;\n    case 'hmac-md5':\n      createKeyLen = 16;\n      outstate.hmac.size = 16;\n      break;\n    case 'hmac-md5-96':\n      createKeyLen = 16;\n      outstate.hmac.size = 12;\n      break;\n  }\n  switch (instate.hmac.type) {\n    case 'hmac-ripemd160':\n    case 'hmac-sha1':\n      checkKeyLen = 20;\n      instate.hmac.size = 20;\n      break;\n    case 'hmac-sha1-96':\n      checkKeyLen = 20;\n      instate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-256':\n      checkKeyLen = 32;\n      instate.hmac.size = 32;\n      break;\n    case 'hmac-sha2-256-96':\n      checkKeyLen = 32;\n      instate.hmac.size = 12;\n      break;\n    case 'hmac-sha2-512':\n      checkKeyLen = 64;\n      instate.hmac.size = 64;\n      break;\n    case 'hmac-sha2-512-96':\n      checkKeyLen = 64;\n      instate.hmac.size = 12;\n      break;\n    case 'hmac-md5':\n      checkKeyLen = 16;\n      instate.hmac.size = 16;\n      break;\n    case 'hmac-md5-96':\n      checkKeyLen = 16;\n      instate.hmac.size = 12;\n      break;\n  }\n\n  if (!outstate.encrypt.isGCM) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'E' : 'F', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (createKeyLen > key.length) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    outstate.hmac.key = key.slice(0, createKeyLen);\n  } else\n    outstate.hmac.key = undefined;\n  if (!instate.decrypt.isGCM) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'F' : 'E', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (checkKeyLen > key.length) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    instate.hmac.key = key.slice(0, checkKeyLen);\n  } else {\n    instate.hmac.key = undefined;\n    instate.hmac.size = 16;\n  }\n\n  outstate.exchangeHash = undefined;\n\n  // Create a reusable buffer for message verification purposes\n  if (!instate.hmac.buf\n      || instate.hmac.buf.length !== instate.hmac.size)\n    instate.hmac.buf = new Buffer(instate.hmac.size);\n\n  if (outstate.compress.type === 'zlib')\n    outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n  else if (outstate.compress.type === 'none')\n    outstate.compress.instance = false;\n  if (instate.decompress.type === 'zlib')\n    instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n  else if (instate.decompress.type === 'none')\n    instate.decompress.instance = false;\n\n  self.bytesSent = self.bytesReceived = 0;\n\n  if (outstate.status === OUT_REKEYING) {\n    outstate.status = OUT_READY;\n\n    // Empty our outbound buffer of any data we tried to send during the\n    // re-keying process\n    var queue = outstate.rekeyQueue;\n    var qlen = queue.length;\n    var q = 0;\n\n    outstate.rekeyQueue = [];\n\n    for (; q < qlen; ++q) {\n      if (Buffer.isBuffer(queue[q]))\n        send(self, queue[q]);\n      else\n        send(self, queue[q][0], queue[q][1]);\n    }\n\n    // Now empty our inbound buffer of any non-transport layer packets we\n    // received during the re-keying process\n    queue = instate.rekeyQueue;\n    qlen = queue.length;\n    q = 0;\n\n    instate.rekeyQueue = [];\n\n    var curSeqno = instate.seqno;\n    for (; q < qlen; ++q) {\n      instate.seqno = queue[q][0];\n      instate.payload = queue[q][1];\n      if (parsePacket(self) === false)\n        return;\n\n      if (instate.status === IN_INIT) {\n        // We were reset due to some error/disagreement ?\n        return;\n      }\n    }\n    instate.seqno = curSeqno;\n  } else {\n    outstate.status = OUT_READY;\n    if (instate.status === IN_PACKET) {\n      // Explicitly update incoming packet parser status in order to get the\n      // correct decipher, hmac, etc. states.\n\n      // We only get here if the host fingerprint callback was called\n      // asynchronously and the incoming packet parser is still expecting an\n      // unencrypted packet, etc.\n\n      self.debug('DEBUG: Parser: IN_PACKETBEFORE (update) (expecting '\n                 + instate.decrypt.size + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(self,\n                 EXP_TYPE_BYTES,\n                 instate.decrypt.size,\n                 instate.decrypt.buf);\n    }\n    self.emit('ready');\n  }\n}\n\nfunction parsePacket(self, callback) {\n  var instate = self._state.incoming;\n  var outstate = self._state.outgoing;\n  var payload = instate.payload;\n  var seqno = instate.seqno;\n  var serviceName;\n  var lang;\n  var message;\n  var info;\n  var chan;\n  var data;\n  var srcIP;\n  var srcPort;\n  var sender;\n  var window;\n  var packetSize;\n  var recipient;\n  var description;\n  var socketPath;\n\n  if (++instate.seqno > MAX_SEQNO)\n    instate.seqno = 0;\n\n  if (instate.ignoreNext) {\n    self.debug('DEBUG: Parser: Packet ignored');\n    instate.ignoreNext = false;\n    return;\n  }\n\n  var type = payload[0];\n  if (type === undefined)\n    return false;\n\n  // If we receive a packet during handshake that is not the expected packet\n  // and it is not one of: DISCONNECT, IGNORE, UNIMPLEMENTED, or DEBUG, then we\n  // close the stream\n  if (outstate.status !== OUT_READY\n      && MESSAGE[type] !== instate.expectedPacket\n      && type < 1\n      && type > 4) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + MESSAGE[type]);\n    // XXX: Potential issue where the module user decides to initiate a rekey\n    // via KEXINIT() (which sets `expectedPacket`) after receiving a packet\n    // and there is still another packet already waiting to be parsed at the\n    // time the KEXINIT is written. this will cause an unexpected disconnect...\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (type === MESSAGE.CHANNEL_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32    recipient channel\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    // TODO: MAX_CHAN_DATA_LEN here should really be dependent upon the\n    //       channel's packet size. The ssh2 module uses 32KB, so we'll hard\n    //       code this for now ...\n    data = readString(payload, 5, self, callback, 32768);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_DATA:' + chan, data);\n  } else if (type === MESSAGE.CHANNEL_EXTENDED_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n      uint32    recipient channel\n      uint32    data_type_code\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var dataType = readInt(payload, 5, self, callback);\n    if (dataType === false)\n      return false;\n    data = readString(payload, 9, self, callback);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_EXTENDED_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EXTENDED_DATA:' + chan, dataType, data);\n  } else if (type === MESSAGE.CHANNEL_WINDOW_ADJUST) {\n    /*\n      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n      uint32    recipient channel\n      uint32    bytes to add\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var bytesToAdd = readInt(payload, 5, self, callback);\n    if (bytesToAdd === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_WINDOW_ADJUST ('\n               + chan\n               + ', '\n               + bytesToAdd\n               + ')');\n    self.emit('CHANNEL_WINDOW_ADJUST:' + chan, bytesToAdd);\n  } else if (type === MESSAGE.CHANNEL_SUCCESS) {\n    /*\n      byte      SSH_MSG_CHANNEL_SUCCESS\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_SUCCESS ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_SUCCESS:' + chan);\n  } else if (type === MESSAGE.CHANNEL_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_FAILURE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_FAILURE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_FAILURE:' + chan);\n  } else if (type === MESSAGE.CHANNEL_EOF) {\n    /*\n      byte      SSH_MSG_CHANNEL_EOF\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_EOF ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EOF:' + chan);\n  } else if (type === MESSAGE.CHANNEL_OPEN) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN\n      string    channel type in US-ASCII only\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    var chanType = readString(payload, 1, 'ascii', self, callback);\n    if (chanType === false)\n      return false;\n    sender = readInt(payload, payload._pos, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, payload._pos += 4, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, payload._pos += 4, self, callback);\n    if (packetSize === false)\n      return false;\n    var channel;\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_OPEN ('\n               + sender\n               + ', '\n               + chanType\n               + ')');\n\n    if (chanType === 'forwarded-tcpip' // Server->Client\n        || chanType === 'direct-tcpip') { // Client->Server\n      /*\n        string    address that was connected / host to connect\n        uint32    port that was connected / port to connect\n        string    originator IP address\n        uint32    originator port\n      */\n      var destIP = readString(payload,\n                              payload._pos += 4,\n                              'ascii',\n                              self,\n                              callback);\n      if (destIP === false)\n        return false;\n      var destPort = readInt(payload, payload._pos, self, callback);\n      if (destPort === false)\n        return false;\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          destIP: destIP,\n          destPort: destPort,\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else if (// Server->Client\n               chanType === 'forwarded-streamlocal@openssh.com'\n               // Client->Server\n               || chanType === 'direct-streamlocal@openssh.com') {\n      /*\n        string    socket path\n        string    reserved for future use\n      */\n      socketPath = readString(payload,\n                              payload._pos += 4,\n                              'utf8',\n                              self,\n                              callback);\n      if (socketPath === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          socketPath: socketPath,\n        }\n      };\n    } else if (chanType === 'x11') { // Server->Client\n      /*\n        string    originator address (e.g., \"192.168.7.38\")\n        uint32    originator port\n      */\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else {\n      // 'session' (Client->Server), 'auth-agent@openssh.com' (Server->Client)\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {}\n      };\n    }\n\n    self.emit('CHANNEL_OPEN', channel);\n  } else if (type === MESSAGE.CHANNEL_OPEN_CONFIRMATION) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION\n      uint32    recipient channel\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    // \"The 'recipient channel' is the channel number given in the\n    // original open request, and 'sender channel' is the channel number\n    // allocated by the other side.\"\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    sender = readInt(payload, 5, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, 9, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, 13, self, callback);\n    if (packetSize === false)\n      return false;\n\n    info = {\n      recipient: recipient,\n      sender: sender,\n      window: window,\n      packetSize: packetSize\n    };\n\n    if (payload.length > 17)\n      info.data = payload.slice(17);\n\n    self.emit('CHANNEL_OPEN_CONFIRMATION:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_OPEN_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_FAILURE\n      uint32    recipient channel\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    var reasonCode = readInt(payload, 5, self, callback);\n    if (reasonCode === false)\n      return false;\n    description = readString(payload, 9, 'utf8', self, callback);\n    if (description === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    payload._pos = 9;\n    info = {\n      recipient: recipient,\n      reasonCode: reasonCode,\n      reason: CHANNEL_OPEN_FAILURE[reasonCode],\n      description: description,\n      lang: lang\n    };\n\n    self.emit('CHANNEL_OPEN_FAILURE:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_CLOSE) {\n    /*\n      byte      SSH_MSG_CHANNEL_CLOSE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_CLOSE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_CLOSE:' + chan);\n  } else if (type === MESSAGE.IGNORE) {\n    /*\n      byte      SSH_MSG_IGNORE\n      string    data\n    */\n  } else if (type === MESSAGE.DISCONNECT) {\n    /*\n      byte      SSH_MSG_DISCONNECT\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var reason = readInt(payload, 1, self, callback);\n    if (reason === false)\n      return false;\n    var reasonText = DISCONNECT_REASON[reason];\n    description = readString(payload, 5, 'utf8', self, callback);\n    if (description === false)\n      return false;\n\n    lang = readString(payload, payload._pos, 'ascii', self, callback);\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: DISCONNECT ('\n               + reasonText\n               + ')');\n\n    self.emit('DISCONNECT', reasonText, reason, description, lang);\n  } else if (type === MESSAGE.DEBUG) {\n    /*\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 2, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'ascii', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('DEBUG', message, lang);\n  } else if (type === MESSAGE.NEWKEYS) {\n    /*\n      byte      SSH_MSG_NEW_KEYS\n    */\n    self.emit('NEWKEYS');\n  } else if (type === MESSAGE.SERVICE_REQUEST) {\n    /*\n      byte      SSH_MSG_SERVICE_REQUEST\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_REQUEST', serviceName);\n  } else if (type === MESSAGE.SERVICE_ACCEPT) {\n    /*\n      byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_ACCEPT', serviceName);\n  } else if (type === MESSAGE.USERAUTH_REQUEST) {\n    /*\n      byte      SSH_MSG_USERAUTH_REQUEST\n      string    user name in ISO-10646 UTF-8 encoding [RFC3629]\n      string    service name in US-ASCII\n      string    method name in US-ASCII\n      ....      method specific fields\n    */\n    var username = readString(payload, 1, 'utf8', self, callback);\n    if (username === false)\n      return false;\n    var svcName = readString(payload, payload._pos, 'ascii', self, callback);\n    if (svcName === false)\n      return false;\n    var method = readString(payload, payload._pos, 'ascii', self, callback);\n    if (method === false)\n      return false;\n    var methodData;\n\n    if (method === 'password') {\n      methodData = readString(payload,\n                              payload._pos + 1,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method === 'publickey' || method === 'hostbased') {\n      var pkSigned;\n      var keyAlgo;\n      var key;\n      var signature;\n      var blob;\n      var hostname;\n      var userlocal;\n      if (method === 'publickey') {\n        pkSigned = payload[payload._pos++];\n        if (pkSigned === undefined)\n          return false;\n        pkSigned = (pkSigned !== 0);\n      }\n      keyAlgo = readString(payload, payload._pos, 'ascii', self, callback);\n      if (keyAlgo === false)\n        return false;\n      key = readString(payload, payload._pos, self, callback);\n      if (key === false)\n        return false;\n\n      if (pkSigned || method === 'hostbased') {\n        if (method === 'hostbased') {\n          hostname = readString(payload, payload._pos, 'ascii', self, callback);\n          if (hostname === false)\n            return false;\n          userlocal = readString(payload, payload._pos, 'utf8', self, callback);\n          if (userlocal === false)\n            return false;\n        }\n\n        var blobEnd = payload._pos;\n        signature = readString(payload, blobEnd, self, callback);\n        if (signature === false)\n          return false;\n\n        if (signature.length > (4 + keyAlgo.length + 4)\n            && signature.toString('ascii', 4, 4 + keyAlgo.length) === keyAlgo) {\n          // Skip algoLen + algo + sigLen\n          signature = signature.slice(4 + keyAlgo.length + 4);\n        }\n\n        if (keyAlgo === 'ssh-dss') {\n          signature = DSASigBareToBER(signature);\n        } else if (keyAlgo !== 'ssh-rsa' && keyAlgo !== 'ssh-dss') {\n          // ECDSA\n          signature = ECDSASigSSHToASN1(signature, self, callback);\n          if (signature === false)\n            return false;\n        }\n\n        blob = new Buffer(4 + outstate.sessionId.length + blobEnd);\n        blob.writeUInt32BE(outstate.sessionId.length, 0, true);\n        outstate.sessionId.copy(blob, 4);\n        payload.copy(blob, 4 + outstate.sessionId.length, 0, blobEnd);\n      }\n\n      methodData = {\n        keyAlgo: keyAlgo,\n        key: key,\n        signature: signature,\n        blob: blob,\n        localHostname: hostname,\n        localUsername: userlocal\n      };\n    } else if (method === 'keyboard-interactive') {\n      // Skip language, it's deprecated\n      var skipLen = readInt(payload, payload._pos, self, callback);\n      if (skipLen === false)\n        return false;\n      methodData = readString(payload,\n                              payload._pos + 4 + skipLen,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method !== 'none')\n      methodData = payload.slice(payload._pos);\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: USERAUTH_REQUEST ('\n               + method\n               + ')');\n\n    self._state.authsQueue.push(method);\n    self.emit('USERAUTH_REQUEST', username, svcName, method, methodData);\n  } else if (type === MESSAGE.USERAUTH_SUCCESS) {\n    /*\n      byte      SSH_MSG_USERAUTH_SUCCESS\n    */\n    if (outstate.compress.type === 'zlib@openssh.com')\n      outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n    if (instate.decompress.type === 'zlib@openssh.com')\n      instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n    self._state.authsQueue.shift();\n    self.emit('USERAUTH_SUCCESS');\n  } else if (type === MESSAGE.USERAUTH_FAILURE) {\n    /*\n      byte      SSH_MSG_USERAUTH_FAILURE\n      name-list    authentications that can continue\n      boolean      partial success\n    */\n    var auths = readString(payload, 1, 'ascii', self, callback);\n    if (auths === false)\n      return false;\n    var partSuccess = payload[payload._pos];\n    if (partSuccess === undefined)\n      return false;\n\n    partSuccess = (partSuccess !== 0);\n    auths = auths.split(',');\n\n    self._state.authsQueue.shift();\n    self.emit('USERAUTH_FAILURE', auths, partSuccess);\n  } else if (type === MESSAGE.USERAUTH_BANNER) {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 1, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('USERAUTH_BANNER', message, lang);\n  } else if (type === MESSAGE.GLOBAL_REQUEST) {\n    /*\n      byte      SSH_MSG_GLOBAL_REQUEST\n      string    request name in US-ASCII only\n      boolean   want reply\n      ....      request-specific data follows\n    */\n    var request = readString(payload, 1, 'ascii', self, callback);\n    if (request === false)\n      return false;\n    var wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    var reqData;\n\n    wantReply = (wantReply !== 0);\n\n    if (request === 'tcpip-forward' || request === 'cancel-tcpip-forward') {\n      var bindAddr = readString(payload, payload._pos, 'ascii', self, callback);\n      if (bindAddr === false)\n        return false;\n      var bindPort = readInt(payload, payload._pos, self, callback);\n      if (bindPort === false)\n        return false;\n      reqData = {\n        bindAddr: bindAddr,\n        bindPort: bindPort\n      };\n    } else if (request === 'streamlocal-forward@openssh.com'\n               || request === 'cancel-streamlocal-forward@openssh.com') {\n      socketPath = readString(payload, payload._pos, 'utf8', self, callback);\n      if (socketPath === false)\n        return false;\n      reqData = {\n        socketPath: socketPath\n      };\n    } else if (request === 'no-more-sessions@openssh.com') {\n      // No data\n    } else\n      reqData = payload.slice(payload._pos);\n\n    self.emit('GLOBAL_REQUEST', request, wantReply, reqData);\n  } else if (type === MESSAGE.REQUEST_SUCCESS) {\n    /*\n      byte      SSH_MSG_REQUEST_SUCCESS\n      ....      response specific data\n    */\n    if (payload.length > 1)\n      self.emit('REQUEST_SUCCESS', payload.slice(1));\n    else\n      self.emit('REQUEST_SUCCESS');\n  } else if (type === MESSAGE.REQUEST_FAILURE) {\n    /*\n      byte      SSH_MSG_REQUEST_FAILURE\n    */\n    self.emit('REQUEST_FAILURE');\n  } else if (type === MESSAGE.UNIMPLEMENTED) {\n    /*\n      byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number of rejected message\n    */\n    // TODO\n  } else if (type === MESSAGE.KEXINIT)\n    return parse_KEXINIT(self, callback);\n  else if (type === MESSAGE.CHANNEL_REQUEST)\n    return parse_CHANNEL_REQUEST(self, callback);\n  else if (type >= 30 && type <= 49) // Key exchange method-specific messages\n    return parse_KEX(self, type, callback);\n  else if (type >= 60 && type <= 70) // User auth context-specific messages\n    return parse_USERAUTH(self, type, callback);\n  else {\n    // Unknown packet type\n    var unimpl = new Buffer(1 + 4);\n    unimpl[0] = MESSAGE.UNIMPLEMENTED;\n    unimpl.writeUInt32BE(seqno, 1, true);\n    send(self, unimpl);\n  }\n}\n\nfunction parse_KEXINIT(self, callback) {\n  var instate = self._state.incoming;\n  var payload = instate.payload;\n\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  var init = {\n    algorithms: {\n      kex: undefined,\n      srvHostKey: undefined,\n      cs: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      },\n      sc: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      }\n    },\n    languages: {\n      cs: undefined,\n      sc: undefined\n    }\n  };\n  var val;\n\n  val = readList(payload, 17, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.kex = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.srvHostKey = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.cs = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.sc = val;\n\n  var firstFollows = (payload._pos < payload.length\n                      && payload[payload._pos] === 1);\n\n  instate.kexinit = payload;\n\n  self.emit('KEXINIT', init, firstFollows);\n}\n\nfunction parse_KEX(self, type, callback) {\n  var state = self._state;\n  var instate = state.incoming;\n  var payload = instate.payload;\n  var pktType = (RE_GEX.test(state.kexdh)\n                 ? DYNAMIC_KEXDH_MESSAGE[type]\n                 : KEXDH_MESSAGE[type]);\n\n  if (state.outgoing.status === OUT_READY\n      || instate.expectedPacket !== pktType) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + pktType);\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (RE_GEX.test(state.kexdh)) {\n    // Dynamic group exchange-related\n\n    if (self.server) {\n      // TODO: Support group exchange server-side\n      self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n      var err = new Error('DH group exchange not supported by server');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    } else {\n      if (type === MESSAGE.KEXDH_GEX_GROUP) {\n        /*\n          byte    SSH_MSG_KEX_DH_GEX_GROUP\n          mpint   p, safe prime\n          mpint   g, generator for subgroup in GF(p)\n        */\n        var prime = readString(payload, 1, self, callback);\n        if (prime === false)\n          return false;\n        var gen = readString(payload, payload._pos, self, callback);\n        if (gen === false)\n          return false;\n        self.emit('KEXDH_GEX_GROUP', prime, gen);\n      } else if (type === MESSAGE.KEXDH_GEX_REPLY)\n        return parse_KEXDH_REPLY(self, callback);\n    }\n  } else {\n    // Static group or ECDH-related\n\n    if (type === MESSAGE.KEXDH_INIT) {\n      /*\n        byte      SSH_MSG_KEXDH_INIT\n        mpint     e\n      */\n      var e = readString(payload, 1, self, callback);\n      if (e === false)\n        return false;\n\n      self.emit('KEXDH_INIT', e);\n    } else if (type === MESSAGE.KEXDH_REPLY)\n      return parse_KEXDH_REPLY(self, callback);\n  }\n}\n\nfunction parse_KEXDH_REPLY(self, callback) {\n  var payload = self._state.incoming.payload;\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n                / SSH_MSG_KEX_DH_GEX_REPLY\n                / SSH_MSG_KEX_ECDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n  var hostkey = readString(payload, 1, self, callback);\n  if (hostkey === false)\n    return false;\n  var pubkey = readString(payload, payload._pos, self, callback);\n  if (pubkey === false)\n    return false;\n  var sig = readString(payload, payload._pos, self, callback);\n  if (sig === false)\n    return false;\n  var info = {\n    hostkey: hostkey,\n    hostkey_format: undefined,\n    pubkey: pubkey,\n    sig: sig,\n    sig_format: undefined\n  };\n  var hostkey_format = readString(hostkey, 0, 'ascii', self, callback);\n  if (hostkey_format === false)\n    return false;\n  info.hostkey_format = hostkey_format;\n  var sig_format = readString(sig, 0, 'ascii', self, callback);\n  if (sig_format === false)\n    return false;\n  info.sig_format = sig_format;\n  self.emit('KEXDH_REPLY', info);\n}\n\nfunction parse_USERAUTH(self, type, callback) {\n  var state = self._state;\n  var authMethod = state.authsQueue[0];\n  var payload = state.incoming.payload;\n  var message;\n  var lang;\n  var text;\n\n  if (authMethod === 'password') {\n    if (type === MESSAGE.USERAUTH_PASSWD_CHANGEREQ) {\n      /*\n        byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ\n        string    prompt in ISO-10646 UTF-8 encoding\n        string    language tag\n      */\n      message = readString(payload, 1, 'utf8', self, callback);\n      if (message === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      self.emit('USERAUTH_PASSWD_CHANGEREQ', message, lang);\n    }\n  } else if (authMethod === 'keyboard-interactive') {\n    if (type === MESSAGE.USERAUTH_INFO_REQUEST) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_REQUEST\n        string    name (ISO-10646 UTF-8)\n        string    instruction (ISO-10646 UTF-8)\n        string    language tag -- MAY be empty\n        int       num-prompts\n        string    prompt[1] (ISO-10646 UTF-8)\n        boolean   echo[1]\n        ...\n        string    prompt[num-prompts] (ISO-10646 UTF-8)\n        boolean   echo[num-prompts]\n      */\n      var name;\n      var instr;\n      var nprompts;\n\n      name = readString(payload, 1, 'utf8', self, callback);\n      if (name === false)\n        return false;\n      instr = readString(payload, payload._pos, 'utf8', self, callback);\n      if (instr === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      nprompts = readInt(payload, payload._pos, self, callback);\n      if (nprompts === false)\n        return false;\n\n      payload._pos += 4;\n\n      var prompts = [];\n      for (var prompt = 0; prompt < nprompts; ++prompt) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        var echo = payload[payload._pos++];\n        if (echo === undefined)\n          return false;\n        echo = (echo !== 0);\n        prompts.push({\n          prompt: text,\n          echo: echo\n        });\n      }\n      self.emit('USERAUTH_INFO_REQUEST', name, instr, lang, prompts);\n    } else if (type === MESSAGE.USERAUTH_INFO_RESPONSE) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_RESPONSE\n        int       num-responses\n        string    response[1] (ISO-10646 UTF-8)\n        ...\n        string    response[num-responses] (ISO-10646 UTF-8)\n      */\n      var nresponses = readInt(payload, 1, self, callback);\n      if (nresponses === false)\n        return false;\n\n      payload._pos = 5;\n\n      var responses = [];\n      for (var response = 0; response < nresponses; ++response) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        responses.push(text);\n      }\n      self.emit('USERAUTH_INFO_RESPONSE', responses);\n    }\n  } else if (authMethod === 'publickey') {\n    if (type === MESSAGE.USERAUTH_PK_OK) {\n      /*\n        byte      SSH_MSG_USERAUTH_PK_OK\n        string    public key algorithm name from the request\n        string    public key blob from the request\n      */\n      var authsQueue = self._state.authsQueue;\n      if (!authsQueue.length || authsQueue[0] !== 'publickey')\n        return;\n      authsQueue.shift();\n      self.emit('USERAUTH_PK_OK');\n      // XXX: Parse public key info? client currently can ignore it because\n      // there is only one outstanding auth request at any given time, so it\n      // knows which key was OK'd\n    }\n  } else if (authMethod !== undefined) {\n    // Invalid packet for this auth type\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Invalid authentication method: ' + authMethod);\n    err.level = 'protocol';\n    self.emit('error', err);\n  }\n}\n\nfunction parse_CHANNEL_REQUEST(self, callback) {\n  var payload = self._state.incoming.payload;\n  var info;\n  var cols;\n  var rows;\n  var width;\n  var height;\n  var wantReply;\n  var signal;\n\n  var recipient = readInt(payload, 1, self, callback);\n  if (recipient === false)\n    return false;\n  var request = readString(payload, 5, 'ascii', self, callback);\n  if (request === false)\n    return false;\n\n  if (request === 'exit-status') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-status\"\n      boolean   FALSE\n      uint32    exit_status\n    */\n    var code = readInt(payload, ++payload._pos, self, callback);\n    if (code === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      code: code\n    };\n  } else if (request === 'exit-signal') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n      boolean   core dumped\n      string    error message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var coredump;\n    if (!(self.remoteBugs & BUGS.OLD_EXIT)) {\n      signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n      if (signal === false)\n        return false;\n      coredump = payload[payload._pos++];\n      if (coredump === undefined)\n        return false;\n      coredump = (coredump !== 0);\n    } else {\n      /*\n        Instead of `signal name` and `core dumped`, we have just:\n\n        uint32  signal number\n      */\n      signal = readInt(payload, ++payload._pos, self, callback);\n      if (signal === false)\n        return false;\n      switch (signal) {\n        case 1:\n          signal = 'HUP';\n          break;\n        case 2:\n          signal = 'INT';\n          break;\n        case 3:\n          signal = 'QUIT';\n          break;\n        case 6:\n          signal = 'ABRT';\n          break;\n        case 9:\n          signal = 'KILL';\n          break;\n        case 14:\n          signal = 'ALRM';\n          break;\n        case 15:\n          signal = 'TERM';\n          break;\n        default:\n          // Unknown or OS-specific\n          signal = 'UNKNOWN (' + signal + ')';\n      }\n      coredump = false;\n    }\n    var description = readString(payload, payload._pos, 'utf8', self,\n                                 callback);\n    if (description === false)\n      return false;\n    var lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: signal,\n      coredump: coredump,\n      description: description,\n      lang: lang\n    };\n  } else if (request === 'pty-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"pty-req\"\n      boolean   want_reply\n      string    TERM environment variable value (e.g., vt100)\n      uint32    terminal width, characters (e.g., 80)\n      uint32    terminal height, rows (e.g., 24)\n      uint32    terminal width, pixels (e.g., 640)\n      uint32    terminal height, pixels (e.g., 480)\n      string    encoded terminal modes\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var term = readString(payload, payload._pos, 'ascii', self, callback);\n    if (term === false)\n      return false;\n    cols = readInt(payload, payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    var modes = readString(payload, payload._pos += 4, self, callback);\n    if (modes === false)\n      return false;\n    modes = bytesToModes(modes);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      term: term,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height,\n      modes: modes\n    };\n  } else if (request === 'window-change') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"window-change\"\n      boolean   FALSE\n      uint32    terminal width, columns\n      uint32    terminal height, rows\n      uint32    terminal width, pixels\n      uint32    terminal height, pixels\n    */\n    cols = readInt(payload, ++payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height\n    };\n  } else if (request === 'x11-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"x11-req\"\n      boolean   want reply\n      boolean   single connection\n      string    x11 authentication protocol\n      string    x11 authentication cookie\n      uint32    x11 screen number\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var single = payload[payload._pos++];\n    if (single === undefined)\n      return false;\n    single = (single !== 0);\n    var protocol = readString(payload, payload._pos, 'ascii', self, callback);\n    if (protocol === false)\n      return false;\n    var cookie = readString(payload, payload._pos, 'hex', self, callback);\n    if (cookie === false)\n      return false;\n    var screen = readInt(payload, payload._pos, self, callback);\n    if (screen === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      single: single,\n      protocol: protocol,\n      cookie: cookie,\n      screen: screen\n    };\n  } else if (request === 'env') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"env\"\n      boolean   want reply\n      string    variable name\n      string    variable value\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var key = readString(payload, payload._pos, 'utf8', self, callback);\n    if (key === false)\n      return false;\n    var val = readString(payload, payload._pos, 'utf8', self, callback);\n    if (val === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      key: key,\n      val: val\n    };\n  } else if (request === 'shell') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"shell\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else if (request === 'exec') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exec\"\n      boolean   want reply\n      string    command\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var command = readString(payload, payload._pos, 'utf8', self, callback);\n    if (command === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      command: command\n    };\n  } else if (request === 'subsystem') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"subsystem\"\n      boolean   want reply\n      string    subsystem name\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var subsystem = readString(payload, payload._pos, 'utf8', self, callback);\n    if (subsystem === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      subsystem: subsystem\n    };\n  } else if (request === 'signal') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n    */\n    signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n    if (signal === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: 'SIG' + signal\n    };\n  } else if (request === 'xon-xoff') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"xon-xoff\"\n      boolean   FALSE\n      boolean   client can do\n    */\n    var clientControl = payload[++payload._pos];\n    if (clientControl === undefined)\n      return false;\n    clientControl = (clientControl !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      clientControl: clientControl\n    };\n  } else if (request === 'auth-agent-req@openssh.com') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"auth-agent-req@openssh.com\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else {\n    // Unknown request type\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  }\n  self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_REQUEST ('\n             + recipient\n             + ', '\n             + request\n             + ')');\n  self.emit('CHANNEL_REQUEST:' + recipient, info);\n}\n\nfunction hmacVerify(self, data) {\n  var instate = self._state.incoming;\n  var hmac = instate.hmac;\n\n  self.debug('DEBUG: Parser: Verifying MAC');\n\n  if (instate.decrypt.isGCM) {\n    var decrypt = instate.decrypt;\n    var instance = decrypt.instance;\n\n    instance.setAuthTag(data);\n\n    var payload = instance.update(instate.packet);\n    instate.payload = payload.slice(1, instate.packet.length + 4 - payload[0]);\n    //instance.final();\n    iv_inc(decrypt.iv);\n\n    decrypt.instance = crypto.createDecipheriv(\n                         SSH_TO_OPENSSL[decrypt.type],\n                         decrypt.key,\n                         decrypt.iv\n                       );\n    decrypt.instance.setAutoPadding(false);\n    return true;\n  } else {\n    var calcHmac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n\n    hmac.bufCompute.writeUInt32BE(instate.seqno, 0, true);\n    hmac.bufCompute.writeUInt32BE(instate.pktLen, 4, true);\n    hmac.bufCompute[8] = instate.padLen;\n\n    calcHmac.update(hmac.bufCompute);\n    calcHmac.update(instate.packet);\n\n    var mac = calcHmac.digest('binary');\n    if (mac.length > instate.hmac.size)\n      mac = mac.slice(0, instate.hmac.size);\n    return (mac === data.toString('binary'));\n  }\n}\n\nfunction decryptData(self, data) {\n  var instance = self._state.incoming.decrypt.instance;\n  self.debug('DEBUG: Parser: Decrypting');\n  return instance.update(data);\n}\n\nfunction expectData(self, type, amount, bufferKey) {\n  var expect = self._state.incoming.expect;\n  expect.amount = amount;\n  expect.type = type;\n  expect.ptr = 0;\n  if (bufferKey && self[bufferKey])\n    expect.buf = self[bufferKey];\n  else if (amount)\n    expect.buf = new Buffer(amount);\n}\n\nfunction readList(buffer, start, stream, callback) {\n  var list = readString(buffer, start, 'ascii', stream, callback);\n  return (list !== false ? (list.length ? list.split(',') : []) : false);\n}\n\nfunction bytesToModes(buffer) {\n  var modes = {};\n\n  for (var i = 0, len = buffer.length, opcode; i < len; i += 5) {\n    opcode = buffer[i];\n    if (opcode === TERMINAL_MODE.TTY_OP_END\n        || TERMINAL_MODE[opcode] === undefined\n        || i + 5 > len)\n      break;\n    modes[TERMINAL_MODE[opcode]] = buffer.readUInt32BE(i + 1, true);\n  }\n\n  return modes;\n}\n\nfunction modesToBytes(modes) {\n  var RE_IS_NUM = /^\\d+$/;\n  var keys = Object.keys(modes);\n  var b = 0;\n  var bytes = [];\n\n  for (var i = 0, len = keys.length, key, opcode, val; i < len; ++i) {\n    key = keys[i];\n    opcode = TERMINAL_MODE[key];\n    if (opcode\n        && !RE_IS_NUM.test(key)\n        && typeof modes[key] === 'number'\n        && key !== 'TTY_OP_END') {\n      val = modes[key];\n      bytes[b++] = opcode;\n      bytes[b++] = (val >>> 24) & 0xFF;\n      bytes[b++] = (val >>> 16) & 0xFF;\n      bytes[b++] = (val >>> 8) & 0xFF;\n      bytes[b++] = val & 0xFF;\n    }\n  }\n\n  bytes[b] = TERMINAL_MODE.TTY_OP_END;\n\n  return bytes;\n}\n\n// Shared outgoing functions\nfunction KEXINIT(self, cb) { // Client/Server\n  randBytes(16, function(myCookie) {\n    /*\n      byte         SSH_MSG_KEXINIT\n      byte[16]     cookie (random bytes)\n      name-list    kex_algorithms\n      name-list    server_host_key_algorithms\n      name-list    encryption_algorithms_client_to_server\n      name-list    encryption_algorithms_server_to_client\n      name-list    mac_algorithms_client_to_server\n      name-list    mac_algorithms_server_to_client\n      name-list    compression_algorithms_client_to_server\n      name-list    compression_algorithms_server_to_client\n      name-list    languages_client_to_server\n      name-list    languages_server_to_client\n      boolean      first_kex_packet_follows\n      uint32       0 (reserved for future extension)\n    */\n    var algos = self.config.algorithms;\n\n    var kexBuf = algos.kexBuf;\n    if (self.remoteBugs & BUGS.BAD_DHGEX) {\n      var copied = false;\n      var kexList = algos.kex;\n      for (var j = kexList.length - 1; j >= 0; --j) {\n        if (kexList[j].indexOf('group-exchange') !== -1) {\n          if (!copied) {\n            kexList = kexList.slice();\n            copied = true;\n          }\n          kexList.splice(j, 1);\n        }\n      }\n      if (copied)\n        kexBuf = new Buffer(kexList.join(','));\n    }\n\n    var hostKeyBuf = algos.serverHostKeyBuf;\n\n    var kexInitSize = 1 + 16\n                      + 4 + kexBuf.length\n                      + 4 + hostKeyBuf.length\n                      + (2 * (4 + algos.cipherBuf.length))\n                      + (2 * (4 + algos.hmacBuf.length))\n                      + (2 * (4 + algos.compressBuf.length))\n                      + (2 * (4 /* languages skipped */))\n                      + 1 + 4;\n    var buf = new Buffer(kexInitSize);\n    var p = 17;\n\n    buf.fill(0);\n\n    buf[0] = MESSAGE.KEXINIT;\n\n    if (myCookie !== false)\n      myCookie.copy(buf, 1);\n\n    buf.writeUInt32BE(kexBuf.length, p, true);\n    p += 4;\n    kexBuf.copy(buf, p);\n    p += kexBuf.length;\n\n    buf.writeUInt32BE(hostKeyBuf.length, p, true);\n    p += 4;\n    hostKeyBuf.copy(buf, p);\n    p += hostKeyBuf.length;\n\n    buf.writeUInt32BE(algos.cipherBuf.length, p, true);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    buf.writeUInt32BE(algos.cipherBuf.length, p, true);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    buf.writeUInt32BE(algos.hmacBuf.length, p, true);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    buf.writeUInt32BE(algos.hmacBuf.length, p, true);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    buf.writeUInt32BE(algos.compressBuf.length, p, true);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    buf.writeUInt32BE(algos.compressBuf.length, p, true);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    // Skip language lists, first_kex_packet_follows, and reserved bytes\n\n    self.debug('DEBUG: Outgoing: Writing KEXINIT');\n\n    self._state.incoming.expectedPacket = 'KEXINIT';\n\n    var outstate = self._state.outgoing;\n\n    outstate.kexinit = buf;\n\n    if (outstate.status === OUT_READY) {\n      // We are the one starting the rekeying process ...\n      outstate.status = OUT_REKEYING;\n    }\n\n    send(self, buf, cb, true);\n  });\n  return true;\n}\n\nfunction KEXDH_INIT(self) { // Client\n  var state = self._state;\n  var outstate = state.outgoing;\n  var buf = new Buffer(1 + 4 + outstate.pubkey.length);\n\n  if (RE_GEX.test(state.kexdh)) {\n    state.incoming.expectedPacket = 'KEXDH_GEX_REPLY';\n    buf[0] = MESSAGE.KEXDH_GEX_INIT;\n    self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_INIT');\n  } else {\n    state.incoming.expectedPacket = 'KEXDH_REPLY';\n    buf[0] = MESSAGE.KEXDH_INIT;\n    if (state.kexdh !== 'group')\n      self.debug('DEBUG: Outgoing: Writing KEXECDH_INIT');\n    else\n      self.debug('DEBUG: Outgoing: Writing KEXDH_INIT');\n  }\n\n  buf.writeUInt32BE(outstate.pubkey.length, 1, true);\n  outstate.pubkey.copy(buf, 5);\n\n  return send(self, buf, undefined, true);\n}\n\nfunction KEXDH_REPLY(self, e) { // Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n  var curHostKey = self.config.hostKeys[state.hostkeyFormat];\n  var hostkey = curHostKey.publicKey.public;\n  var hostkeyAlgo = curHostKey.publicKey.fulltype;\n  var privateKey = curHostKey.privateKey.privateOrig;\n\n  // e === client DH public key\n\n  var slicepos = -1;\n  for (var i = 0, len = e.length; i < len; ++i) {\n    if (e[i] === 0)\n      ++slicepos;\n    else\n      break;\n  }\n  if (slicepos > -1)\n    e = e.slice(slicepos + 1);\n\n  var secret = tryComputeSecret(state.kex, e);\n  if (secret instanceof Error) {\n    secret.message = 'Error while computing DH secret ('\n                     + state.kexdh + '): '\n                     + secret.message;\n    secret.level = 'handshake';\n    self.emit('error', secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hashAlgo;\n  if (state.kexdh === 'group')\n    hashAlgo = 'sha1';\n  else\n    hashAlgo = RE_KEX_HASH.exec(state.kexdh)[1];\n\n  var hash = crypto.createHash(hashAlgo);\n\n  var len_ident = Buffer.byteLength(instate.identRaw);\n  var len_sident = Buffer.byteLength(self.config.ident);\n  var len_init = instate.kexinit.length;\n  var len_sinit = outstate.kexinit.length;\n  var len_hostkey = hostkey.length;\n  var len_pubkey = e.length;\n  var len_spubkey = outstate.pubkey.length;\n  var len_secret = secret.length;\n\n  var idx_spubkey = 0;\n  var idx_secret = 0;\n\n  while (outstate.pubkey[idx_spubkey] === 0x00) {\n    ++idx_spubkey;\n    --len_spubkey;\n  }\n  while (secret[idx_secret] === 0x00) {\n    ++idx_secret;\n    --len_secret;\n  }\n  if (e[0] & 0x80)\n    ++len_pubkey;\n  if (outstate.pubkey[idx_spubkey] & 0x80)\n    ++len_spubkey;\n  if (secret[idx_secret] & 0x80)\n    ++len_secret;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var isGEX = RE_GEX.test(state.kexdh);\n  var len_gex_prime = 0;\n  var len_gex_gen = 0;\n  var idx_gex_prime = 0;\n  var idx_gex_gen = 0;\n  var gex_prime;\n  var gex_gen;\n  if (isGEX) {\n    gex_prime = state.kex.getPrime();\n    gex_gen = state.kex.getGenerator();\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    while (gex_prime[idx_gex_prime] === 0x00) {\n      ++idx_gex_prime;\n      --len_gex_prime;\n    }\n    while (gex_gen[idx_gex_gen] === 0x00) {\n      ++idx_gex_gen;\n      --len_gex_gen;\n    }\n    if (gex_prime[idx_gex_prime] & 0x80)\n      ++len_gex_prime;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      ++len_gex_gen;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n  var bp = 0;\n  var exchangeBuf = new Buffer(exchangeBufLen);\n\n  exchangeBuf.writeUInt32BE(len_ident, bp, true);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  exchangeBuf.writeUInt32BE(len_sident, bp, true);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  exchangeBuf.writeUInt32BE(len_init, bp, true);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  instate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_sinit, bp, true);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  outstate.kexinit = undefined;\n\n  exchangeBuf.writeUInt32BE(len_hostkey, bp, true);\n  bp += 4;\n  hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (isGEX) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    exchangeBuf.writeUInt32BE(len_gex_prime, bp, true);\n    bp += 4;\n    if (gex_prime[idx_gex_prime] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_prime.copy(exchangeBuf, bp, idx_gex_prime); // p\n    bp += len_gex_prime - (gex_prime[idx_gex_prime] & 0x80 ? 1 : 0);\n\n    exchangeBuf.writeUInt32BE(len_gex_gen, bp, true);\n    bp += 4;\n    if (gex_gen[idx_gex_gen] & 0x80)\n      exchangeBuf[bp++] = 0;\n    gex_gen.copy(exchangeBuf, bp, idx_gex_gen); // g\n    bp += len_gex_gen - (gex_gen[idx_gex_gen] & 0x80 ? 1 : 0);\n  }\n\n  exchangeBuf.writeUInt32BE(len_pubkey, bp, true);\n  bp += 4;\n  if (e[0] & 0x80)\n    exchangeBuf[bp++] = 0;\n  e.copy(exchangeBuf, bp); // e\n  bp += len_pubkey - (e[0] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_spubkey, bp, true);\n  bp += 4;\n  if (outstate.pubkey[idx_spubkey] & 0x80)\n    exchangeBuf[bp++] = 0;\n  outstate.pubkey.copy(exchangeBuf, bp, idx_spubkey); // f\n  bp += len_spubkey - (outstate.pubkey[idx_spubkey] & 0x80 ? 1 : 0);\n\n  exchangeBuf.writeUInt32BE(len_secret, bp, true);\n  bp += 4;\n  if (secret[idx_secret] & 0x80)\n    exchangeBuf[bp++] = 0;\n  secret.copy(exchangeBuf, bp, idx_secret); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = secret;\n\n  var signAlgo;\n  switch (hostkeyAlgo) {\n    case 'ssh-rsa':\n      signAlgo = 'RSA-SHA1';\n      break;\n    case 'ssh-dss':\n      signAlgo = 'DSA-SHA1';\n      break;\n    case 'ecdsa-sha2-nistp256':\n      signAlgo = 'sha256';\n      break;\n    case 'ecdsa-sha2-nistp384':\n      signAlgo = 'sha384';\n      break;\n    case 'ecdsa-sha2-nistp521':\n      signAlgo = 'sha512';\n      break;\n  }\n  var signer = crypto.createSign(signAlgo);\n  var signature;\n  signer.update(outstate.exchangeHash);\n  signature = trySign(signer, privateKey);\n  if (signature instanceof Error) {\n    signature.message = 'Error while signing data with host key ('\n                        + hostkeyAlgo + '): '\n                        + signature.message;\n    signature.level = 'handshake';\n    self.emit('error', signature);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (signAlgo === 'DSA-SHA1') {\n    signature = DSASigBERToBare(signature);\n  } else if (signAlgo !== 'RSA-SHA1') {\n    // ECDSA\n    signature = ECDSASigASN1ToSSH(signature);\n  }\n\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n\n  var siglen = 4 + hostkeyAlgo.length + 4 + signature.length;\n  var buf = new Buffer(1\n                       + 4 + len_hostkey\n                       + 4 + len_spubkey\n                       + 4 + siglen);\n\n  bp = 0;\n  buf[bp] = (!isGEX ? MESSAGE.KEXDH_REPLY : MESSAGE.KEXDH_GEX_REPLY);\n  ++bp;\n\n  buf.writeUInt32BE(len_hostkey, bp, true);\n  bp += 4;\n  hostkey.copy(buf, bp); // K_S\n  bp += len_hostkey;\n\n  buf.writeUInt32BE(len_spubkey, bp, true);\n  bp += 4;\n  if (outstate.pubkey[idx_spubkey] & 0x80)\n    buf[bp++] = 0;\n  outstate.pubkey.copy(buf, bp, idx_spubkey); // f\n  bp += len_spubkey - (outstate.pubkey[idx_spubkey] & 0x80 ? 1 : 0);\n\n  buf.writeUInt32BE(siglen, bp, true);\n  bp += 4;\n  buf.writeUInt32BE(hostkeyAlgo.length, bp, true);\n  bp += 4;\n  buf.write(hostkeyAlgo, bp, hostkeyAlgo.length, 'ascii');\n  bp += hostkeyAlgo.length;\n  buf.writeUInt32BE(signature.length, bp, true);\n  bp += 4;\n  signature.copy(buf, bp);\n\n  state.incoming.expectedPacket = 'NEWKEYS';\n\n  if (isGEX)\n    self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_REPLY');\n  else if (state.kexdh !== 'group')\n    self.debug('DEBUG: Outgoing: Writing KEXECDH_REPLY');\n  else\n    self.debug('DEBUG: Outgoing: Writing KEXDH_REPLY');\n  send(self, buf, undefined, true);\n\n  outstate.sentNEWKEYS = true;\n  self.debug('DEBUG: Outgoing: Writing NEWKEYS');\n  return send(self, NEWKEYS_PACKET, undefined, true);\n}\n\nfunction KEXDH_GEX_REQ(self) { // Client\n  self._state.incoming.expectedPacket = 'KEXDH_GEX_GROUP';\n\n  self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_REQUEST');\n  return send(self, KEXDH_GEX_REQ_PACKET, undefined, true);\n}\n\nfunction send(self, payload, cb, bypass) {\n  var state = self._state;\n\n  if (!state)\n    return false;\n\n  var outstate = state.outgoing;\n  if (outstate.status === OUT_REKEYING && !bypass) {\n    if (typeof cb === 'function')\n      outstate.rekeyQueue.push([payload, cb]);\n    else\n      outstate.rekeyQueue.push(payload);\n    return false;\n  } else if (self._readableState.ended || self._writableState.ended)\n    return false;\n\n  var compress = outstate.compress.instance;\n  if (compress) {\n    compress.write(payload);\n    compress.flush(Z_PARTIAL_FLUSH, function() {\n      if (self._readableState.ended || self._writableState.ended)\n        return;\n      send_(self, compress.read(), cb);\n    });\n    return true;\n  } else\n    return send_(self, payload, cb);\n}\n\nfunction send_(self, payload, cb) {\n  // TODO: Implement length checks\n\n  var state = self._state;\n  var outstate = state.outgoing;\n  var encrypt = outstate.encrypt;\n  var hmac = outstate.hmac;\n  var pktLen;\n  var padLen;\n  var buf;\n  var mac;\n  var ret;\n\n  pktLen = payload.length + 9;\n\n  if (encrypt.instance !== false && encrypt.isGCM) {\n    var ptlen = 1 + payload.length + 4 /* Must have at least 4 bytes padding*/;\n    while ((ptlen % encrypt.size) !== 0)\n      ++ptlen;\n    padLen = ptlen - 1 - payload.length;\n    pktLen = 4 + ptlen;\n  } else {\n    pktLen += ((encrypt.size - 1) * pktLen) % encrypt.size;\n    padLen = pktLen - payload.length - 5;\n  }\n\n  buf = new Buffer(pktLen);\n\n  buf.writeUInt32BE(pktLen - 4, 0, true);\n  buf[4] = padLen;\n  payload.copy(buf, 5);\n\n  var padBytes = crypto.randomBytes(padLen);\n  padBytes.copy(buf, 5 + payload.length);\n\n  if (hmac.type !== false && hmac.key) {\n    mac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n    outstate.bufSeqno.writeUInt32BE(outstate.seqno, 0, true);\n    mac.update(outstate.bufSeqno);\n    mac.update(buf);\n    mac = mac.digest();\n    if (mac.length > outstate.hmac.size)\n      mac = mac.slice(0, outstate.hmac.size);\n  }\n\n  var nb = 0;\n  var encData;\n\n  if (encrypt.instance !== false) {\n    if (encrypt.isGCM) {\n      var encrypter = crypto.createCipheriv(SSH_TO_OPENSSL[encrypt.type],\n                                            encrypt.key,\n                                            encrypt.iv);\n      encrypter.setAutoPadding(false);\n\n      var lenbuf = buf.slice(0, 4);\n\n      encrypter.setAAD(lenbuf);\n      self.push(lenbuf);\n      nb += lenbuf;\n\n      encData = encrypter.update(buf.slice(4));\n      self.push(encData);\n      nb += encData.length;\n\n      var final = encrypter.final();\n      if (final.length) {\n        self.push(final);\n        nb += final.length;\n      }\n\n      var authTag = encrypter.getAuthTag();\n      ret = self.push(authTag);\n      nb += authTag.length;\n\n      iv_inc(encrypt.iv);\n    } else {\n      encData = encrypt.instance.update(buf);\n      self.push(encData);\n      nb += encData.length;\n\n      ret = self.push(mac);\n      nb += mac.length;\n    }\n  } else {\n    ret = self.push(buf);\n    nb = buf.length;\n  }\n\n  self.bytesSent += nb;\n\n  if (++outstate.seqno > MAX_SEQNO)\n    outstate.seqno = 0;\n\n  cb && cb();\n\n  return ret;\n}\n\nfunction randBytes(n, cb) {\n  crypto.randomBytes(n, function retry(err, buf) {\n    if (err)\n      return crypto.randomBytes(n, retry);\n    cb && cb(buf);\n  });\n}\n\nfunction trySign(sig, key) {\n  try {\n    return sig.sign(key);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction tryComputeSecret(dh, e) {\n  try {\n    return dh.computeSecret(e);\n  } catch (err) {\n    return err;\n  }\n}\n\nmodule.exports = SSH2Stream;\nmodule.exports._send = send;\n"}